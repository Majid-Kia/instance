// tslint:disable
/**
 * AbrNOC Gateway
 * API gateway for AbrNOC panels.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AddItemReturnSchema
 */
export interface AddItemReturnSchema {
  /**
   *
   * @type {number}
   * @memberof AddItemReturnSchema
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AddItemReturnSchema
   */
  message?: string;
}
/**
 *
 * @export
 * @interface BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
 */
export interface BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost {
  /**
   *
   * @type {string}
   * @memberof BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
   */
  customerId: string;
}
/**
 *
 * @export
 * @interface BodyAddNoteForCustomerCustomersCustomerIdNotePost
 */
export interface BodyAddNoteForCustomerCustomersCustomerIdNotePost {
  /**
   *
   * @type {string}
   * @memberof BodyAddNoteForCustomerCustomersCustomerIdNotePost
   */
  note: string;
}
/**
 *
 * @export
 * @interface BodyAddOnetimeInvoiceInvoicesOneTimePost
 */
export interface BodyAddOnetimeInvoiceInvoicesOneTimePost {
  /**
   *
   * @type {string}
   * @memberof BodyAddOnetimeInvoiceInvoicesOneTimePost
   */
  customerId: string;
  /**
   *
   * @type {number}
   * @memberof BodyAddOnetimeInvoiceInvoicesOneTimePost
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof BodyAddOnetimeInvoiceInvoicesOneTimePost
   */
  description: string;
}
/**
 *
 * @export
 * @interface BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
 */
export interface BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost {
  /**
   *
   * @type {number}
   * @memberof BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
   */
  credit: number;
  /**
   *
   * @type {string}
   * @memberof BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
   */
  description: string;
}
/**
 *
 * @export
 * @interface BodyAdminLoginAuthAdminLoginPost
 */
export interface BodyAdminLoginAuthAdminLoginPost {
  /**
   *
   * @type {string}
   * @memberof BodyAdminLoginAuthAdminLoginPost
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof BodyAdminLoginAuthAdminLoginPost
   */
  password: string;
}
/**
 *
 * @export
 * @interface BodyChangeEmailAuthChangeEmailPut
 */
export interface BodyChangeEmailAuthChangeEmailPut {
  /**
   *
   * @type {string}
   * @memberof BodyChangeEmailAuthChangeEmailPut
   */
  email: string;
}
/**
 *
 * @export
 * @interface BodyChangeEmailCustomersCustomerIdChangeEmailPost
 */
export interface BodyChangeEmailCustomersCustomerIdChangeEmailPost {
  /**
   *
   * @type {string}
   * @memberof BodyChangeEmailCustomersCustomerIdChangeEmailPost
   */
  email: string;
}
/**
 *
 * @export
 * @interface BodyChangePasswordAuthChangePasswordPost
 */
export interface BodyChangePasswordAuthChangePasswordPost {
  /**
   *
   * @type {string}
   * @memberof BodyChangePasswordAuthChangePasswordPost
   */
  newPassword: string;
  /**
   *
   * @type {string}
   * @memberof BodyChangePasswordAuthChangePasswordPost
   */
  oldPassword: string;
}
/**
 *
 * @export
 * @interface BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
 */
export interface BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost {
  /**
   *
   * @type {string}
   * @memberof BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
   */
  planId: string;
}
/**
 *
 * @export
 * @interface BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
 */
export interface BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost {
  /**
   *
   * @type {string}
   * @memberof BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
   */
  planId: string;
}
/**
 *
 * @export
 * @interface BodyConfirmResetPasswordAuthConfirmResetPasswordPost
 */
export interface BodyConfirmResetPasswordAuthConfirmResetPasswordPost {
  /**
   *
   * @type {string}
   * @memberof BodyConfirmResetPasswordAuthConfirmResetPasswordPost
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface BodyCustomerLoginAuthCustomerLoginPost
 */
export interface BodyCustomerLoginAuthCustomerLoginPost {
  /**
   *
   * @type {string}
   * @memberof BodyCustomerLoginAuthCustomerLoginPost
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof BodyCustomerLoginAuthCustomerLoginPost
   */
  password: string;
}
/**
 *
 * @export
 * @interface BodyForgotPasswordAuthForgotPasswordPost
 */
export interface BodyForgotPasswordAuthForgotPasswordPost {
  /**
   *
   * @type {string}
   * @memberof BodyForgotPasswordAuthForgotPasswordPost
   */
  email: string;
}
/**
 *
 * @export
 * @interface BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
 */
export interface BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete {
  /**
   *
   * @type {string}
   * @memberof BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
   */
  customerId: string;
}
/**
 *
 * @export
 * @interface BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
 */
export interface BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost {
  /**
   *
   * @type {string}
   * @memberof BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
   */
  email: string;
}
/**
 *
 * @export
 * @interface BodyShareInvoiceInvoicesInvoiceIdSharePost
 */
export interface BodyShareInvoiceInvoicesInvoiceIdSharePost {
  /**
   *
   * @type {string}
   * @memberof BodyShareInvoiceInvoicesInvoiceIdSharePost
   */
  email?: string;
}
/**
 *
 * @export
 * @interface BodySuspendCustomerCustomersCustomerIdSuspendPost
 */
export interface BodySuspendCustomerCustomersCustomerIdSuspendPost {
  /**
   *
   * @type {string}
   * @memberof BodySuspendCustomerCustomersCustomerIdSuspendPost
   */
  note: string;
}
/**
 *
 * @export
 * @interface BodyUploadFileTicketingAttachmentsUploadPost
 */
export interface BodyUploadFileTicketingAttachmentsUploadPost {
  /**
   *
   * @type {any}
   * @memberof BodyUploadFileTicketingAttachmentsUploadPost
   */
  file: any;
}
/**
 *
 * @export
 * @interface BodyUseCouponPaymentsCouponPost
 */
export interface BodyUseCouponPaymentsCouponPost {
  /**
   *
   * @type {string}
   * @memberof BodyUseCouponPaymentsCouponPost
   */
  code: string;
}
/**
 *
 * @export
 * @interface CouponAmountSchema
 */
export interface CouponAmountSchema {
  /**
   *
   * @type {number}
   * @memberof CouponAmountSchema
   */
  couponAmount: number;
}
/**
 *
 * @export
 * @interface CouponPaginatedListSchema
 */
export interface CouponPaginatedListSchema {
  /**
   *
   * @type {Array<CouponSchema>}
   * @memberof CouponPaginatedListSchema
   */
  coupons: Array<CouponSchema>;
  /**
   *
   * @type {number}
   * @memberof CouponPaginatedListSchema
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof CouponPaginatedListSchema
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface CouponSchema
 */
export interface CouponSchema {
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CouponSchema
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CouponSchema
   */
  description?: string;
  /**
   *
   * @type {CouponTypeEnum}
   * @memberof CouponSchema
   */
  type: CouponTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  expiresAtTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CouponSchema
   */
  createdBy?: string;
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  createdAtTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  beginsAtTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof CouponSchema
   */
  quantity?: number;
  /**
   *
   * @type {boolean}
   * @memberof CouponSchema
   */
  isActive?: boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum CouponTypeEnum {
  OneTimeForAll = "OneTimeForAll",
  OneTimeForListOfUsers = "OneTimeForListOfUsers",
  OneTimeForNewUsers = "OneTimeForNewUsers",
}

/**
 *
 * @export
 * @interface CouponTypesEndpointOutput
 */
export interface CouponTypesEndpointOutput {
  /**
   *
   * @type {Array<string>}
   * @memberof CouponTypesEndpointOutput
   */
  listOfCouponTypes: Array<string>;
}
/**
 *
 * @export
 * @interface CreateCouponInputSchema
 */
export interface CreateCouponInputSchema {
  /**
   *
   * @type {CouponTypeEnum}
   * @memberof CreateCouponInputSchema
   */
  type: CouponTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CreateCouponInputSchema
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CreateCouponInputSchema
   */
  code?: string;
  /**
   *
   * @type {number}
   * @memberof CreateCouponInputSchema
   */
  codeLength?: number;
  /**
   *
   * @type {number}
   * @memberof CreateCouponInputSchema
   */
  quantity?: number;
  /**
   *
   * @type {string}
   * @memberof CreateCouponInputSchema
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof CreateCouponInputSchema
   */
  expiresAtTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof CreateCouponInputSchema
   */
  beginsAtTimestamp?: number;
  /**
   *
   * @type {boolean}
   * @memberof CreateCouponInputSchema
   */
  isActive?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof CreateCouponInputSchema
   */
  userIds?: Array<string>;
}
/**
 *
 * @export
 * @interface CreatePaymentInputSchema
 */
export interface CreatePaymentInputSchema {
  /**
   *
   * @type {number}
   * @memberof CreatePaymentInputSchema
   */
  credit: number;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentInputSchema
   */
  gateway: string;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentInputSchema
   */
  description?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentResponseSchema
 */
export interface CreatePaymentResponseSchema {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentResponseSchema
   */
  url: string;
  /**
   *
   * @type {object}
   * @memberof CreatePaymentResponseSchema
   */
  postData?: object;
}
/**
 *
 * @export
 * @interface CurrentUserInfoSchema
 */
export interface CurrentUserInfoSchema {
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  fullname: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  email: string;
  /**
   *
   * @type {Date}
   * @memberof CurrentUserInfoSchema
   */
  registeredAt: Date;
  /**
   *
   * @type {boolean}
   * @memberof CurrentUserInfoSchema
   */
  isEmailVerified: boolean;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  unverifiedEmail?: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof CurrentUserInfoSchema
   */
  country?: string;
}
/**
 *
 * @export
 * @interface CustomerBillingDetailSchema
 */
export interface CustomerBillingDetailSchema {
  /**
   *
   * @type {string}
   * @memberof CustomerBillingDetailSchema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CustomerBillingDetailSchema
   */
  balance: string;
  /**
   *
   * @type {string}
   * @memberof CustomerBillingDetailSchema
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CustomerBillingDetailSchema
   */
  threshold?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerBillingDetailSchema
   */
  credit: string;
  /**
   *
   * @type {number}
   * @memberof CustomerBillingDetailSchema
   */
  suspendTimestamp?: number;
  /**
   *
   * @type {CustomerStatusEnum}
   * @memberof CustomerBillingDetailSchema
   */
  status?: CustomerStatusEnum;
  /**
   *
   * @type {number}
   * @memberof CustomerBillingDetailSchema
   */
  invoicesCount?: number;
  /**
   *
   * @type {number}
   * @memberof CustomerBillingDetailSchema
   */
  finalizedPaymentsCount?: number;
  /**
   *
   * @type {number}
   * @memberof CustomerBillingDetailSchema
   */
  negativeBalanceSuccessiveDays?: number;
}
/**
 *
 * @export
 * @interface CustomerDetailOutputSchema
 */
export interface CustomerDetailOutputSchema {
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  fullname: string;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  email: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  registeredAt: Date;
  /**
   *
   * @type {number}
   * @memberof CustomerDetailOutputSchema
   */
  registeredAtTimestamp: number;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CustomerDetailOutputSchema
   */
  roles?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  group?: string;
  /**
   *
   * @type {UserStatusEnum}
   * @memberof CustomerDetailOutputSchema
   */
  status: UserStatusEnum;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  country?: string;
  /**
   *
   * @type {boolean}
   * @memberof CustomerDetailOutputSchema
   */
  isSuspended?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CustomerDetailOutputSchema
   */
  isBillingSuspended?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CustomerDetailOutputSchema
   */
  isAdminSuspended?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CustomerDetailOutputSchema
   */
  isActive?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CustomerDetailOutputSchema
   */
  isEmailVerified?: boolean;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  adminSuspensionNote?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  lastAdminSuspendedAt?: Date;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  lastAdminSuspendedBy?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  adminNote?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  emailChangedAt?: Date;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  passwordChangedAt?: Date;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  unverifiedEmail?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  lastLoginAt?: Date;
  /**
   *
   * @type {string}
   * @memberof CustomerDetailOutputSchema
   */
  lastLoginFrom?: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerDetailOutputSchema
   */
  lastModifiedAt?: Date;
}
/**
 *
 * @export
 * @interface CustomerListOutputSchema
 */
export interface CustomerListOutputSchema {
  /**
   *
   * @type {Array<CustomerOutputSchema>}
   * @memberof CustomerListOutputSchema
   */
  customers?: Array<CustomerOutputSchema>;
  /**
   *
   * @type {number}
   * @memberof CustomerListOutputSchema
   */
  totalCount: number;
  /**
   *
   * @type {number}
   * @memberof CustomerListOutputSchema
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface CustomerOutputSchema
 */
export interface CustomerOutputSchema {
  /**
   *
   * @type {string}
   * @memberof CustomerOutputSchema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CustomerOutputSchema
   */
  fullname: string;
  /**
   *
   * @type {string}
   * @memberof CustomerOutputSchema
   */
  email: string;
  /**
   *
   * @type {Date}
   * @memberof CustomerOutputSchema
   */
  registeredAt: Date;
  /**
   *
   * @type {number}
   * @memberof CustomerOutputSchema
   */
  registeredAtTimestamp: number;
  /**
   *
   * @type {string}
   * @memberof CustomerOutputSchema
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CustomerOutputSchema
   */
  roles?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CustomerOutputSchema
   */
  group?: string;
  /**
   *
   * @type {UserStatusEnum}
   * @memberof CustomerOutputSchema
   */
  status: UserStatusEnum;
}
/**
 *
 * @export
 * @interface CustomerProfileUpdateInputSchema
 */
export interface CustomerProfileUpdateInputSchema {
  /**
   *
   * @type {string}
   * @memberof CustomerProfileUpdateInputSchema
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerProfileUpdateInputSchema
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerProfileUpdateInputSchema
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerProfileUpdateInputSchema
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof CustomerProfileUpdateInputSchema
   */
  country?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum CustomerStatusEnum {
  Active = "active",
  Suspended = "suspended",
  Stopped = "stopped",
  Terminated = "terminated",
}

/**
 *
 * @export
 * @interface FollowUpCreateSchema
 */
export interface FollowUpCreateSchema {
  /**
   *
   * @type {string}
   * @memberof FollowUpCreateSchema
   */
  content: string;
  /**
   *
   * @type {number}
   * @memberof FollowUpCreateSchema
   */
  itemsId: number;
  /**
   *
   * @type {Array<number>}
   * @memberof FollowUpCreateSchema
   */
  attachmentIds?: Array<number>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface IaasSpecificationSchema
 */
export interface IaasSpecificationSchema {
  /**
   *
   * @type {number}
   * @memberof IaasSpecificationSchema
   */
  cpu: number;
  /**
   *
   * @type {number}
   * @memberof IaasSpecificationSchema
   */
  ram: number;
  /**
   *
   * @type {number}
   * @memberof IaasSpecificationSchema
   */
  ramInMB: number;
  /**
   *
   * @type {number}
   * @memberof IaasSpecificationSchema
   */
  storage: number;
  /**
   *
   * @type {number}
   * @memberof IaasSpecificationSchema
   */
  bandwidthInTB: number;
}
/**
 *
 * @export
 * @interface InitSessionOutputSchema
 */
export interface InitSessionOutputSchema {
  /**
   *
   * @type {string}
   * @memberof InitSessionOutputSchema
   */
  gtoken: string;
}
/**
 *
 * @export
 * @interface InstanceCreateSchema
 */
export interface InstanceCreateSchema {
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  planId: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  customerId?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  hostname: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  osId: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  region: string;
  /**
   *
   * @type {string}
   * @memberof InstanceCreateSchema
   */
  tag?: string;
  /**
   *
   * @type {Array<number>}
   * @memberof InstanceCreateSchema
   */
  sshKeyIds?: Array<number>;
}
/**
 *
 * @export
 * @interface InstanceDetailSchema
 */
export interface InstanceDetailSchema {
  /**
   * The size of the disk in GB.
   * @type {number}
   * @memberof InstanceDetailSchema
   */
  disk: number;
  /**
   * Host Name
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  hostname: string;
  /**
   * A unique ID for the VPS Instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  id: string;
  /**
   * Creation timestamp
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  insertedAt?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  osId: string;
  /**
   *
   * @type {OsSchema}
   * @memberof InstanceDetailSchema
   */
  os?: OsSchema;
  /**
   * The amount of RAM in MB.
   * @type {number}
   * @memberof InstanceDetailSchema
   */
  ram: number;
  /**
   * The region where the Instance is located.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  region: string;
  /**
   * Update timestamp
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  updatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  userId: string;
  /**
   * Number of vCPUs.
   * @type {number}
   * @memberof InstanceDetailSchema
   */
  vcpuCount: number;
  /**
   * The current status.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  status?: string;
  /**
   * The main IPv4 address.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  mainIp?: string;
  /**
   * A unique ID for the VPS Plan
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  planId?: string;
  /**
   * The time when cloud-init initialization finished.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  initializedAt?: string;
  /**
   * The admin note on this instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  adminNote?: string;
  /**
   * The admin suspend note.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  adminSuspendNote?: string;
  /**
   * HTTPS link to the Zyrrus noVNC Web Console.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  vnc?: string;
  /**
   * The user-supplied tag for this instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  tag?: string;
  /**
   * Monthly bandwidth quota in GB.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  allowedBandwidth?: string;
  /**
   * The main MAC address.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  mainMac?: string;
  /**
   * The IPv4 netmask in dot-decimal notation.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  netmaskV4?: string;
  /**
   * The user-supplied label for this instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  label?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InstanceDetailSchema
   */
  sshKeys?: Array<string>;
  /**
   * The time when billing suspended the instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  suspendByBillingAt?: string;
  /**
   * The billing suspend note.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  billingSuspendNote?: string;
  /**
   * The time when admin suspended the instance.
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  suspendByAdminAt?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  networkStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  powerStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  hostNode?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  vncStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  defaultPassword?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceDetailSchema
   */
  gatewayV4?: string;
}
/**
 *
 * @export
 * @interface InstanceListSchema
 */
export interface InstanceListSchema {
  /**
   *
   * @type {Array<InstanceSchema>}
   * @memberof InstanceListSchema
   */
  instances: Array<InstanceSchema>;
}
/**
 *
 * @export
 * @interface InstanceSchema
 */
export interface InstanceSchema {
  /**
   * The size of the disk in GB.
   * @type {number}
   * @memberof InstanceSchema
   */
  disk: number;
  /**
   * Host Name
   * @type {string}
   * @memberof InstanceSchema
   */
  hostname: string;
  /**
   * A unique ID for the VPS Instance.
   * @type {string}
   * @memberof InstanceSchema
   */
  id: string;
  /**
   * Creation timestamp
   * @type {string}
   * @memberof InstanceSchema
   */
  insertedAt?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceSchema
   */
  osId: string;
  /**
   *
   * @type {OsSchema}
   * @memberof InstanceSchema
   */
  os?: OsSchema;
  /**
   * The amount of RAM in MB.
   * @type {number}
   * @memberof InstanceSchema
   */
  ram: number;
  /**
   * The region where the Instance is located.
   * @type {string}
   * @memberof InstanceSchema
   */
  region: string;
  /**
   * Update timestamp
   * @type {string}
   * @memberof InstanceSchema
   */
  updatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceSchema
   */
  userId: string;
  /**
   * Number of vCPUs.
   * @type {number}
   * @memberof InstanceSchema
   */
  vcpuCount: number;
  /**
   * The current status.
   * @type {string}
   * @memberof InstanceSchema
   */
  status?: string;
  /**
   * The main IPv4 address.
   * @type {string}
   * @memberof InstanceSchema
   */
  mainIp?: string;
  /**
   * A unique ID for the VPS Plan
   * @type {string}
   * @memberof InstanceSchema
   */
  planId?: string;
}
/**
 *
 * @export
 * @interface InstanceSuspendInputSchema
 */
export interface InstanceSuspendInputSchema {
  /**
   * Suspend instance or active instance.
   * @type {ToggleInstanceSuspensionEnum}
   * @memberof InstanceSuspendInputSchema
   */
  instance?: ToggleInstanceSuspensionEnum;
  /**
   * Suspend network or active network.
   * @type {ToggleInstanceSuspensionEnum}
   * @memberof InstanceSuspendInputSchema
   */
  network?: ToggleInstanceSuspensionEnum;
  /**
   * The note for suspension.
   * @type {string}
   * @memberof InstanceSuspendInputSchema
   */
  note?: string;
}
/**
 *
 * @export
 * @interface InstanceSuspendOutputSchema
 */
export interface InstanceSuspendOutputSchema {
  /**
   * \"suspended\" or \"active\".
   * @type {string}
   * @memberof InstanceSuspendOutputSchema
   */
  instanceStatus?: string;
  /**
   * \"suspended\" or \"active\".
   * @type {string}
   * @memberof InstanceSuspendOutputSchema
   */
  networkStatus?: string;
}
/**
 *
 * @export
 * @interface InstanceUpdateSchema
 */
export interface InstanceUpdateSchema {
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  customerId?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  planId?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  hostname?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  osId?: string;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  region?: string;
  /**
   *
   * @type {boolean}
   * @memberof InstanceUpdateSchema
   */
  reinstallOs?: boolean;
  /**
   *
   * @type {string}
   * @memberof InstanceUpdateSchema
   */
  tag?: string;
}
/**
 *
 * @export
 * @interface InstructionsHasBeenSent
 */
export interface InstructionsHasBeenSent {
  /**
   *
   * @type {string}
   * @memberof InstructionsHasBeenSent
   */
  detail?: string;
}
/**
 *
 * @export
 * @interface InvoiceDetailSchema
 */
export interface InvoiceDetailSchema {
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailSchema
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailSchema
   */
  customerId: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailSchema
   */
  fullname?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailSchema
   */
  startTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailSchema
   */
  endTimestamp?: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailSchema
   */
  email?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailSchema
   */
  amount?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailSchema
   */
  roundedAmount?: number;
  /**
   *
   * @type {InvoiceStatusEnum}
   * @memberof InvoiceDetailSchema
   */
  status?: InvoiceStatusEnum;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailSchema
   */
  interval?: string;
  /**
   *
   * @type {Array<InvoiceItemSchema>}
   * @memberof InvoiceDetailSchema
   */
  invoiceItems?: Array<InvoiceItemSchema>;
}
/**
 *
 * @export
 * @interface InvoiceItemSchema
 */
export interface InvoiceItemSchema {
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  invoiceId?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  resourceId?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  startTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  usage?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  costPerUnit?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  subtotal?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceItemSchema
   */
  roundedSubtotal?: number;
  /**
   *
   * @type {boolean}
   * @memberof InvoiceItemSchema
   */
  closed?: boolean;
  /**
   *
   * @type {string}
   * @memberof InvoiceItemSchema
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceItemSchema
   */
  subDescription?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceItemSchema
   */
  type?: string;
  /**
   *
   * @type {ResourceSchema}
   * @memberof InvoiceItemSchema
   */
  resource?: ResourceSchema;
}
/**
 *
 * @export
 * @interface InvoiceListResponseSchema
 */
export interface InvoiceListResponseSchema {
  /**
   *
   * @type {Array<InvoiceSchema>}
   * @memberof InvoiceListResponseSchema
   */
  invoices?: Array<InvoiceSchema>;
  /**
   *
   * @type {number}
   * @memberof InvoiceListResponseSchema
   */
  totalPages?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceListResponseSchema
   */
  totalCount?: number;
}
/**
 *
 * @export
 * @interface InvoiceSchema
 */
export interface InvoiceSchema {
  /**
   *
   * @type {number}
   * @memberof InvoiceSchema
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceSchema
   */
  customerId: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceSchema
   */
  fullname?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceSchema
   */
  startTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceSchema
   */
  endTimestamp?: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceSchema
   */
  email?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceSchema
   */
  amount?: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceSchema
   */
  roundedAmount?: number;
  /**
   *
   * @type {InvoiceStatusEnum}
   * @memberof InvoiceSchema
   */
  status?: InvoiceStatusEnum;
  /**
   *
   * @type {string}
   * @memberof InvoiceSchema
   */
  interval?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum InvoiceStatusEnum {
  Open = "open",
  Closed = "closed",
}

/**
 *
 * @export
 * @interface LoginOutputSchema
 */
export interface LoginOutputSchema {
  /**
   *
   * @type {string}
   * @memberof LoginOutputSchema
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof LoginOutputSchema
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface OsListSchema
 */
export interface OsListSchema {
  /**
   *
   * @type {Array<OsSchema>}
   * @memberof OsListSchema
   */
  os?: Array<OsSchema>;
}
/**
 *
 * @export
 * @interface OsSchema
 */
export interface OsSchema {
  /**
   * The Operating System id.
   * @type {string}
   * @memberof OsSchema
   */
  id?: string;
  /**
   * The Operating System architecture.
   * @type {string}
   * @memberof OsSchema
   */
  arch?: string;
  /**
   * The Operating System family.
   * @type {string}
   * @memberof OsSchema
   */
  family?: string;
  /**
   * The Operating System description.
   * @type {string}
   * @memberof OsSchema
   */
  name?: string;
}
/**
 *
 * @export
 * @interface PaymentDetailSchema
 */
export interface PaymentDetailSchema {
  /**
   *
   * @type {number}
   * @memberof PaymentDetailSchema
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof PaymentDetailSchema
   */
  timestamp: number;
  /**
   *
   * @type {Date}
   * @memberof PaymentDetailSchema
   */
  date: Date;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  customerId: string;
  /**
   *
   * @type {number}
   * @memberof PaymentDetailSchema
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  paymentGateway: string;
  /**
   *
   * @type {PaymentStatusEnum}
   * @memberof PaymentDetailSchema
   */
  status: PaymentStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailSchema
   */
  additionalData?: string;
}
/**
 *
 * @export
 * @interface PaymentListResponseSchema
 */
export interface PaymentListResponseSchema {
  /**
   *
   * @type {Array<PaymentSchema>}
   * @memberof PaymentListResponseSchema
   */
  payments: Array<PaymentSchema>;
  /**
   *
   * @type {number}
   * @memberof PaymentListResponseSchema
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof PaymentListResponseSchema
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface PaymentSchema
 */
export interface PaymentSchema {
  /**
   *
   * @type {number}
   * @memberof PaymentSchema
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof PaymentSchema
   */
  timestamp: number;
  /**
   *
   * @type {Date}
   * @memberof PaymentSchema
   */
  date: Date;
  /**
   *
   * @type {string}
   * @memberof PaymentSchema
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentSchema
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentSchema
   */
  customerId: string;
  /**
   *
   * @type {number}
   * @memberof PaymentSchema
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof PaymentSchema
   */
  paymentGateway: string;
  /**
   *
   * @type {PaymentStatusEnum}
   * @memberof PaymentSchema
   */
  status: PaymentStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PaymentSchema
   */
  description?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum PaymentStatusEnum {
  New = "new",
  Pending = "pending",
  Accepted = "accepted",
  Rejected = "rejected",
}

/**
 *
 * @export
 * @interface PlanListSchema
 */
export interface PlanListSchema {
  /**
   *
   * @type {Array<PlanSchema>}
   * @memberof PlanListSchema
   */
  plans?: Array<PlanSchema>;
}
/**
 *
 * @export
 * @interface PlanSchema
 */
export interface PlanSchema {
  /**
   *
   * @type {string}
   * @memberof PlanSchema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PlanSchema
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof PlanSchema
   */
  regionId?: string;
  /**
   *
   * @type {string}
   * @memberof PlanSchema
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof PlanSchema
   */
  hourlyPrice: number;
  /**
   *
   * @type {number}
   * @memberof PlanSchema
   */
  monthlyPrice: number;
  /**
   *
   * @type {string}
   * @memberof PlanSchema
   */
  logoURL: string;
  /**
   *
   * @type {IaasSpecificationSchema}
   * @memberof PlanSchema
   */
  specification: IaasSpecificationSchema;
}
/**
 *
 * @export
 * @interface ResourceSchema
 */
export interface ResourceSchema {
  /**
   *
   * @type {number}
   * @memberof ResourceSchema
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  tag?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  title?: string;
  /**
   *
   * @type {number}
   * @memberof ResourceSchema
   */
  startTimestamp?: number;
  /**
   *
   * @type {number}
   * @memberof ResourceSchema
   */
  endTimestamp?: number;
  /**
   *
   * @type {Date}
   * @memberof ResourceSchema
   */
  startDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof ResourceSchema
   */
  endDate?: Date;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  customerId?: string;
  /**
   *
   * @type {number}
   * @memberof ResourceSchema
   */
  costPerUnit?: number;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  externalId?: string;
  /**
   *
   * @type {boolean}
   * @memberof ResourceSchema
   */
  autoTermination?: boolean;
  /**
   *
   * @type {string}
   * @memberof ResourceSchema
   */
  stopReason?: string;
}
/**
 *
 * @export
 * @interface SSHKeyReadSchema
 */
export interface SSHKeyReadSchema {
  /**
   *
   * @type {string}
   * @memberof SSHKeyReadSchema
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SSHKeyReadSchema
   */
  publicKey: string;
  /**
   *
   * @type {string}
   * @memberof SSHKeyReadSchema
   */
  customerId: string;
  /**
   *
   * @type {number}
   * @memberof SSHKeyReadSchema
   */
  id: number;
}
/**
 *
 * @export
 * @interface SSHKeyWriteSchema
 */
export interface SSHKeyWriteSchema {
  /**
   *
   * @type {string}
   * @memberof SSHKeyWriteSchema
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SSHKeyWriteSchema
   */
  publicKey: string;
  /**
   *
   * @type {string}
   * @memberof SSHKeyWriteSchema
   */
  customerId?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum SortTypeEnum {
  DESC = "DESC",
  ASC = "ASC",
}

/**
 *
 * @export
 * @interface TicketCreateSchema
 */
export interface TicketCreateSchema {
  /**
   *
   * @type {string}
   * @memberof TicketCreateSchema
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof TicketCreateSchema
   */
  itilcategoriesId: number;
  /**
   * 1: very low <br>2: low <br>3: medium <br>4: high <br>5: very high <br>
   * @type {TicketUrgencyEnum}
   * @memberof TicketCreateSchema
   */
  urgency?: TicketUrgencyEnum;
  /**
   *
   * @type {string}
   * @memberof TicketCreateSchema
   */
  content: string;
  /**
   *
   * @type {string}
   * @memberof TicketCreateSchema
   */
  vmId?: string;
  /**
   *
   * @type {Array<number>}
   * @memberof TicketCreateSchema
   */
  attachmentIds?: Array<number>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum TicketUrgencyEnum {
  NUMBER_1 = 1,
  NUMBER_2 = 2,
  NUMBER_3 = 3,
  NUMBER_4 = 4,
  NUMBER_5 = 5,
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum ToggleInstanceSuspensionEnum {
  Active = "active",
  Suspend = "suspend",
}

/**
 *
 * @export
 * @interface TransactionListResponseSchema
 */
export interface TransactionListResponseSchema {
  /**
   *
   * @type {Array<TransactionSchema>}
   * @memberof TransactionListResponseSchema
   */
  transactions?: Array<TransactionSchema>;
  /**
   *
   * @type {number}
   * @memberof TransactionListResponseSchema
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof TransactionListResponseSchema
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface TransactionSchema
 */
export interface TransactionSchema {
  /**
   *
   * @type {number}
   * @memberof TransactionSchema
   */
  id: number;
  /**
   *
   * @type {TransactionTypeEnum}
   * @memberof TransactionSchema
   */
  type: TransactionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TransactionSchema
   */
  customerId: string;
  /**
   *
   * @type {number}
   * @memberof TransactionSchema
   */
  timestamp: number;
  /**
   *
   * @type {number}
   * @memberof TransactionSchema
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof TransactionSchema
   */
  description?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum TransactionTypeEnum {
  Invoice = "invoice",
  Payment = "payment",
}

/**
 *
 * @export
 * @interface UpdateCurrentUserProfile
 */
export interface UpdateCurrentUserProfile {
  /**
   *
   * @type {string}
   * @memberof UpdateCurrentUserProfile
   */
  fullname?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCurrentUserProfile
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCurrentUserProfile
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCurrentUserProfile
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCurrentUserProfile
   */
  country?: string;
}
/**
 *
 * @export
 * @interface UseCouponAsPaymentResponseSchema
 */
export interface UseCouponAsPaymentResponseSchema {
  /**
   *
   * @type {string}
   * @memberof UseCouponAsPaymentResponseSchema
   */
  detail: string;
  /**
   *
   * @type {CouponAmountSchema}
   * @memberof UseCouponAsPaymentResponseSchema
   */
  data: CouponAmountSchema;
}
/**
 *
 * @export
 * @interface UserRegistrationSchema
 */
export interface UserRegistrationSchema {
  /**
   *
   * @type {string}
   * @memberof UserRegistrationSchema
   */
  fullname: string;
  /**
   *
   * @type {string}
   * @memberof UserRegistrationSchema
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserRegistrationSchema
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserRegistrationSchema
   */
  phoneNumber?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export enum UserStatusEnum {
  Verified = "verified",
  Unverified = "unverified",
  Suspended = "suspended",
}

/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationError
   */
  loc: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Admin Login
     * @param {BodyAdminLoginAuthAdminLoginPost} bodyAdminLoginAuthAdminLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminLoginAuthAdminLoginPost(
      bodyAdminLoginAuthAdminLoginPost: BodyAdminLoginAuthAdminLoginPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'bodyAdminLoginAuthAdminLoginPost' is not null or undefined
      if (
        bodyAdminLoginAuthAdminLoginPost === null ||
        bodyAdminLoginAuthAdminLoginPost === undefined
      ) {
        throw new RequiredError(
          "bodyAdminLoginAuthAdminLoginPost",
          "Required parameter bodyAdminLoginAuthAdminLoginPost was null or undefined when calling adminLoginAuthAdminLoginPost."
        );
      }
      const localVarPath = `/auth/admin-login`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyAdminLoginAuthAdminLoginPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyAdminLoginAuthAdminLoginPost !== undefined
              ? bodyAdminLoginAuthAdminLoginPost
              : {}
          )
        : bodyAdminLoginAuthAdminLoginPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Change Email
     * @param {string} xToken
     * @param {BodyChangeEmailAuthChangeEmailPut} bodyChangeEmailAuthChangeEmailPut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailAuthChangeEmailPut(
      xToken: string,
      bodyChangeEmailAuthChangeEmailPut: BodyChangeEmailAuthChangeEmailPut,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling changeEmailAuthChangeEmailPut."
        );
      }
      // verify required parameter 'bodyChangeEmailAuthChangeEmailPut' is not null or undefined
      if (
        bodyChangeEmailAuthChangeEmailPut === null ||
        bodyChangeEmailAuthChangeEmailPut === undefined
      ) {
        throw new RequiredError(
          "bodyChangeEmailAuthChangeEmailPut",
          "Required parameter bodyChangeEmailAuthChangeEmailPut was null or undefined when calling changeEmailAuthChangeEmailPut."
        );
      }
      const localVarPath = `/auth/change-email`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyChangeEmailAuthChangeEmailPut !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyChangeEmailAuthChangeEmailPut !== undefined
              ? bodyChangeEmailAuthChangeEmailPut
              : {}
          )
        : bodyChangeEmailAuthChangeEmailPut || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    User changes her/his own password by providing credentials or tokens.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Password
     * @param {string} xToken
     * @param {BodyChangePasswordAuthChangePasswordPost} bodyChangePasswordAuthChangePasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePasswordAuthChangePasswordPost(
      xToken: string,
      bodyChangePasswordAuthChangePasswordPost: BodyChangePasswordAuthChangePasswordPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling changePasswordAuthChangePasswordPost."
        );
      }
      // verify required parameter 'bodyChangePasswordAuthChangePasswordPost' is not null or undefined
      if (
        bodyChangePasswordAuthChangePasswordPost === null ||
        bodyChangePasswordAuthChangePasswordPost === undefined
      ) {
        throw new RequiredError(
          "bodyChangePasswordAuthChangePasswordPost",
          "Required parameter bodyChangePasswordAuthChangePasswordPost was null or undefined when calling changePasswordAuthChangePasswordPost."
        );
      }
      const localVarPath = `/auth/change-password`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyChangePasswordAuthChangePasswordPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyChangePasswordAuthChangePasswordPost !== undefined
              ? bodyChangePasswordAuthChangePasswordPost
              : {}
          )
        : bodyChangePasswordAuthChangePasswordPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint will get called when user clicks on reset password token. From here user will be redirected to frontend.  Frontend should serve ``{base_front_url}/resetpassword`` route for this purpose. Based on validation result redirection URL will contain following query parameters: - Valid token: **token={token}&status=Valid** - Invalid token: **token={token}&status=Invalid** - Expired token: **token={token}&status=Expired&email={urlencoded-email}**  **URL encoded email example**: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Check Reset Password Token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenAuthCheckResetPasswordTokenGet(
      token: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling checkResetPasswordTokenAuthCheckResetPasswordTokenGet."
        );
      }
      const localVarPath = `/auth/check-reset-password-token`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a token and sets email verification flag as True  Note: The token can be used only once, if the procedure failed then user should request for a new token.  At the end redirects to frontend.  At the front side two path should handle the redirection. - For success: **{base_front_url}/verificationsuccess** - For failure: **{base_front_url}/verificationfailure**  ``Note:`` In failure case if token was expired, user email will be passed in the querystrings. **{base_front_url}/verificationfailure?email=urlencoded_email**.  ``URL encoded email example``: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Confirm Email
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmailAuthConfirmEmailGet(
      token: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling confirmEmailAuthConfirmEmailGet."
        );
      }
      const localVarPath = `/auth/confirm-email`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provide the token sent to the user\'s email and a new password, if the token is valid one password will be changed.
     * @summary Confirm Reset Password
     * @param {string} token
     * @param {BodyConfirmResetPasswordAuthConfirmResetPasswordPost} bodyConfirmResetPasswordAuthConfirmResetPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmResetPasswordAuthConfirmResetPasswordPost(
      token: string,
      bodyConfirmResetPasswordAuthConfirmResetPasswordPost: BodyConfirmResetPasswordAuthConfirmResetPasswordPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling confirmResetPasswordAuthConfirmResetPasswordPost."
        );
      }
      // verify required parameter 'bodyConfirmResetPasswordAuthConfirmResetPasswordPost' is not null or undefined
      if (
        bodyConfirmResetPasswordAuthConfirmResetPasswordPost === null ||
        bodyConfirmResetPasswordAuthConfirmResetPasswordPost === undefined
      ) {
        throw new RequiredError(
          "bodyConfirmResetPasswordAuthConfirmResetPasswordPost",
          "Required parameter bodyConfirmResetPasswordAuthConfirmResetPasswordPost was null or undefined when calling confirmResetPasswordAuthConfirmResetPasswordPost."
        );
      }
      const localVarPath = `/auth/confirm-reset-password`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyConfirmResetPasswordAuthConfirmResetPasswordPost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyConfirmResetPasswordAuthConfirmResetPasswordPost !== undefined
              ? bodyConfirmResetPasswordAuthConfirmResetPasswordPost
              : {}
          )
        : bodyConfirmResetPasswordAuthConfirmResetPasswordPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Customer Login
     * @param {BodyCustomerLoginAuthCustomerLoginPost} bodyCustomerLoginAuthCustomerLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerLoginAuthCustomerLoginPost(
      bodyCustomerLoginAuthCustomerLoginPost: BodyCustomerLoginAuthCustomerLoginPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'bodyCustomerLoginAuthCustomerLoginPost' is not null or undefined
      if (
        bodyCustomerLoginAuthCustomerLoginPost === null ||
        bodyCustomerLoginAuthCustomerLoginPost === undefined
      ) {
        throw new RequiredError(
          "bodyCustomerLoginAuthCustomerLoginPost",
          "Required parameter bodyCustomerLoginAuthCustomerLoginPost was null or undefined when calling customerLoginAuthCustomerLoginPost."
        );
      }
      const localVarPath = `/auth/customer-login`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyCustomerLoginAuthCustomerLoginPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyCustomerLoginAuthCustomerLoginPost !== undefined
              ? bodyCustomerLoginAuthCustomerLoginPost
              : {}
          )
        : bodyCustomerLoginAuthCustomerLoginPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Forgot Password
     * @param {BodyForgotPasswordAuthForgotPasswordPost} bodyForgotPasswordAuthForgotPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPasswordAuthForgotPasswordPost(
      bodyForgotPasswordAuthForgotPasswordPost: BodyForgotPasswordAuthForgotPasswordPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'bodyForgotPasswordAuthForgotPasswordPost' is not null or undefined
      if (
        bodyForgotPasswordAuthForgotPasswordPost === null ||
        bodyForgotPasswordAuthForgotPasswordPost === undefined
      ) {
        throw new RequiredError(
          "bodyForgotPasswordAuthForgotPasswordPost",
          "Required parameter bodyForgotPasswordAuthForgotPasswordPost was null or undefined when calling forgotPasswordAuthForgotPasswordPost."
        );
      }
      const localVarPath = `/auth/forgot-password`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyForgotPasswordAuthForgotPasswordPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyForgotPasswordAuthForgotPasswordPost !== undefined
              ? bodyForgotPasswordAuthForgotPasswordPost
              : {}
          )
        : bodyForgotPasswordAuthForgotPasswordPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use profile/user-info instead.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoAuthUserInfoGet(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getCurrentUserInfoAuthUserInfoGet."
        );
      }
      const localVarPath = `/auth/user-info`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provide your refresh token at header to gain a new pair of access and refresh tokens.   This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Refresh Token
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshTokenAuthRefreshTokenPost(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling refreshTokenAuthRefreshTokenPost."
        );
      }
      const localVarPath = `/auth/refresh-token`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register User
     * @param {UserRegistrationSchema} userRegistrationSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUserAuthPost(
      userRegistrationSchema: UserRegistrationSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'userRegistrationSchema' is not null or undefined
      if (
        userRegistrationSchema === null ||
        userRegistrationSchema === undefined
      ) {
        throw new RequiredError(
          "userRegistrationSchema",
          "Required parameter userRegistrationSchema was null or undefined when calling registerUserAuthPost."
        );
      }
      const localVarPath = `/auth`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof userRegistrationSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            userRegistrationSchema !== undefined ? userRegistrationSchema : {}
          )
        : userRegistrationSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove Unverified Email
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailAuthUnverifiedEmailDelete(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling removeUnverifiedEmailAuthUnverifiedEmailDelete."
        );
      }
      const localVarPath = `/auth/unverified-email`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resend Email Verification Token
     * @param {BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost} bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
      bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost: BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost' is not null or undefined
      if (
        bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost ===
          null ||
        bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost ===
          undefined
      ) {
        throw new RequiredError(
          "bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost",
          "Required parameter bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost was null or undefined when calling resendEmailVerificationTokenAuthResendEmailVerificationTokenPost."
        );
      }
      const localVarPath = `/auth/resend-email-verification-token`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost !==
              undefined
              ? bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
              : {}
          )
        : bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost ||
          "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Profile
     * @param {string} xToken
     * @param {UpdateCurrentUserProfile} [updateCurrentUserProfile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileAuthUpdateProfilePut(
      xToken: string,
      updateCurrentUserProfile?: UpdateCurrentUserProfile,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling updateProfileAuthUpdateProfilePut."
        );
      }
      const localVarPath = `/auth/update-profile`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateCurrentUserProfile !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateCurrentUserProfile !== undefined
              ? updateCurrentUserProfile
              : {}
          )
        : updateCurrentUserProfile || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Admin Login
     * @param {BodyAdminLoginAuthAdminLoginPost} bodyAdminLoginAuthAdminLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminLoginAuthAdminLoginPost(
      bodyAdminLoginAuthAdminLoginPost: BodyAdminLoginAuthAdminLoginPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<LoginOutputSchema> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).adminLoginAuthAdminLoginPost(bodyAdminLoginAuthAdminLoginPost, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Change Email
     * @param {string} xToken
     * @param {BodyChangeEmailAuthChangeEmailPut} bodyChangeEmailAuthChangeEmailPut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailAuthChangeEmailPut(
      xToken: string,
      bodyChangeEmailAuthChangeEmailPut: BodyChangeEmailAuthChangeEmailPut,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).changeEmailAuthChangeEmailPut(
        xToken,
        bodyChangeEmailAuthChangeEmailPut,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    User changes her/his own password by providing credentials or tokens.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Password
     * @param {string} xToken
     * @param {BodyChangePasswordAuthChangePasswordPost} bodyChangePasswordAuthChangePasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePasswordAuthChangePasswordPost(
      xToken: string,
      bodyChangePasswordAuthChangePasswordPost: BodyChangePasswordAuthChangePasswordPost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).changePasswordAuthChangePasswordPost(
        xToken,
        bodyChangePasswordAuthChangePasswordPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint will get called when user clicks on reset password token. From here user will be redirected to frontend.  Frontend should serve ``{base_front_url}/resetpassword`` route for this purpose. Based on validation result redirection URL will contain following query parameters: - Valid token: **token={token}&status=Valid** - Invalid token: **token={token}&status=Invalid** - Expired token: **token={token}&status=Expired&email={urlencoded-email}**  **URL encoded email example**: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Check Reset Password Token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenAuthCheckResetPasswordTokenGet(
      token: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).checkResetPasswordTokenAuthCheckResetPasswordTokenGet(token, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Gets a token and sets email verification flag as True  Note: The token can be used only once, if the procedure failed then user should request for a new token.  At the end redirects to frontend.  At the front side two path should handle the redirection. - For success: **{base_front_url}/verificationsuccess** - For failure: **{base_front_url}/verificationfailure**  ``Note:`` In failure case if token was expired, user email will be passed in the querystrings. **{base_front_url}/verificationfailure?email=urlencoded_email**.  ``URL encoded email example``: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Confirm Email
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmailAuthConfirmEmailGet(
      token: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).confirmEmailAuthConfirmEmailGet(token, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Provide the token sent to the user\'s email and a new password, if the token is valid one password will be changed.
     * @summary Confirm Reset Password
     * @param {string} token
     * @param {BodyConfirmResetPasswordAuthConfirmResetPasswordPost} bodyConfirmResetPasswordAuthConfirmResetPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmResetPasswordAuthConfirmResetPasswordPost(
      token: string,
      bodyConfirmResetPasswordAuthConfirmResetPasswordPost: BodyConfirmResetPasswordAuthConfirmResetPasswordPost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).confirmResetPasswordAuthConfirmResetPasswordPost(
        token,
        bodyConfirmResetPasswordAuthConfirmResetPasswordPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Customer Login
     * @param {BodyCustomerLoginAuthCustomerLoginPost} bodyCustomerLoginAuthCustomerLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerLoginAuthCustomerLoginPost(
      bodyCustomerLoginAuthCustomerLoginPost: BodyCustomerLoginAuthCustomerLoginPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<LoginOutputSchema> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).customerLoginAuthCustomerLoginPost(
        bodyCustomerLoginAuthCustomerLoginPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Forgot Password
     * @param {BodyForgotPasswordAuthForgotPasswordPost} bodyForgotPasswordAuthForgotPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPasswordAuthForgotPasswordPost(
      bodyForgotPasswordAuthForgotPasswordPost: BodyForgotPasswordAuthForgotPasswordPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstructionsHasBeenSent> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).forgotPasswordAuthForgotPasswordPost(
        bodyForgotPasswordAuthForgotPasswordPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Use profile/user-info instead.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoAuthUserInfoGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CurrentUserInfoSchema> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).getCurrentUserInfoAuthUserInfoGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Provide your refresh token at header to gain a new pair of access and refresh tokens.   This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Refresh Token
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshTokenAuthRefreshTokenPost(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<LoginOutputSchema> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).refreshTokenAuthRefreshTokenPost(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Register User
     * @param {UserRegistrationSchema} userRegistrationSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUserAuthPost(
      userRegistrationSchema: UserRegistrationSchema,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).registerUserAuthPost(userRegistrationSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Remove Unverified Email
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailAuthUnverifiedEmailDelete(
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).removeUnverifiedEmailAuthUnverifiedEmailDelete(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Resend Email Verification Token
     * @param {BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost} bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
      bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost: BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstructionsHasBeenSent> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
        bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Profile
     * @param {string} xToken
     * @param {UpdateCurrentUserProfile} [updateCurrentUserProfile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileAuthUpdateProfilePut(
      xToken: string,
      updateCurrentUserProfile?: UpdateCurrentUserProfile,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration
      ).updateProfileAuthUpdateProfilePut(
        xToken,
        updateCurrentUserProfile,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Admin Login
     * @param {BodyAdminLoginAuthAdminLoginPost} bodyAdminLoginAuthAdminLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminLoginAuthAdminLoginPost(
      bodyAdminLoginAuthAdminLoginPost: BodyAdminLoginAuthAdminLoginPost,
      options?: any
    ): AxiosPromise<LoginOutputSchema> {
      return AuthApiFp(configuration).adminLoginAuthAdminLoginPost(
        bodyAdminLoginAuthAdminLoginPost,
        options
      )(axios, basePath);
    },
    /**
     *
     * @summary Change Email
     * @param {string} xToken
     * @param {BodyChangeEmailAuthChangeEmailPut} bodyChangeEmailAuthChangeEmailPut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailAuthChangeEmailPut(
      xToken: string,
      bodyChangeEmailAuthChangeEmailPut: BodyChangeEmailAuthChangeEmailPut,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(configuration).changeEmailAuthChangeEmailPut(
        xToken,
        bodyChangeEmailAuthChangeEmailPut,
        options
      )(axios, basePath);
    },
    /**
     *    User changes her/his own password by providing credentials or tokens.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Password
     * @param {string} xToken
     * @param {BodyChangePasswordAuthChangePasswordPost} bodyChangePasswordAuthChangePasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePasswordAuthChangePasswordPost(
      xToken: string,
      bodyChangePasswordAuthChangePasswordPost: BodyChangePasswordAuthChangePasswordPost,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(configuration).changePasswordAuthChangePasswordPost(
        xToken,
        bodyChangePasswordAuthChangePasswordPost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint will get called when user clicks on reset password token. From here user will be redirected to frontend.  Frontend should serve ``{base_front_url}/resetpassword`` route for this purpose. Based on validation result redirection URL will contain following query parameters: - Valid token: **token={token}&status=Valid** - Invalid token: **token={token}&status=Invalid** - Expired token: **token={token}&status=Expired&email={urlencoded-email}**  **URL encoded email example**: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Check Reset Password Token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenAuthCheckResetPasswordTokenGet(
      token: string,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(
        configuration
      ).checkResetPasswordTokenAuthCheckResetPasswordTokenGet(token, options)(
        axios,
        basePath
      );
    },
    /**
     * Gets a token and sets email verification flag as True  Note: The token can be used only once, if the procedure failed then user should request for a new token.  At the end redirects to frontend.  At the front side two path should handle the redirection. - For success: **{base_front_url}/verificationsuccess** - For failure: **{base_front_url}/verificationfailure**  ``Note:`` In failure case if token was expired, user email will be passed in the querystrings. **{base_front_url}/verificationfailure?email=urlencoded_email**.  ``URL encoded email example``: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
     * @summary Confirm Email
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmailAuthConfirmEmailGet(
      token: string,
      options?: any
    ): AxiosPromise<void> {
      return AuthApiFp(configuration).confirmEmailAuthConfirmEmailGet(
        token,
        options
      )(axios, basePath);
    },
    /**
     * Provide the token sent to the user\'s email and a new password, if the token is valid one password will be changed.
     * @summary Confirm Reset Password
     * @param {string} token
     * @param {BodyConfirmResetPasswordAuthConfirmResetPasswordPost} bodyConfirmResetPasswordAuthConfirmResetPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmResetPasswordAuthConfirmResetPasswordPost(
      token: string,
      bodyConfirmResetPasswordAuthConfirmResetPasswordPost: BodyConfirmResetPasswordAuthConfirmResetPasswordPost,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(
        configuration
      ).confirmResetPasswordAuthConfirmResetPasswordPost(
        token,
        bodyConfirmResetPasswordAuthConfirmResetPasswordPost,
        options
      )(axios, basePath);
    },
    /**
     *
     * @summary Customer Login
     * @param {BodyCustomerLoginAuthCustomerLoginPost} bodyCustomerLoginAuthCustomerLoginPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerLoginAuthCustomerLoginPost(
      bodyCustomerLoginAuthCustomerLoginPost: BodyCustomerLoginAuthCustomerLoginPost,
      options?: any
    ): AxiosPromise<LoginOutputSchema> {
      return AuthApiFp(configuration).customerLoginAuthCustomerLoginPost(
        bodyCustomerLoginAuthCustomerLoginPost,
        options
      )(axios, basePath);
    },
    /**
     *
     * @summary Forgot Password
     * @param {BodyForgotPasswordAuthForgotPasswordPost} bodyForgotPasswordAuthForgotPasswordPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPasswordAuthForgotPasswordPost(
      bodyForgotPasswordAuthForgotPasswordPost: BodyForgotPasswordAuthForgotPasswordPost,
      options?: any
    ): AxiosPromise<InstructionsHasBeenSent> {
      return AuthApiFp(configuration).forgotPasswordAuthForgotPasswordPost(
        bodyForgotPasswordAuthForgotPasswordPost,
        options
      )(axios, basePath);
    },
    /**
     * Use profile/user-info instead.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoAuthUserInfoGet(
      xToken: string,
      options?: any
    ): AxiosPromise<CurrentUserInfoSchema> {
      return AuthApiFp(configuration).getCurrentUserInfoAuthUserInfoGet(
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * Provide your refresh token at header to gain a new pair of access and refresh tokens.   This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Refresh Token
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshTokenAuthRefreshTokenPost(
      xToken: string,
      options?: any
    ): AxiosPromise<LoginOutputSchema> {
      return AuthApiFp(configuration).refreshTokenAuthRefreshTokenPost(
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *
     * @summary Register User
     * @param {UserRegistrationSchema} userRegistrationSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUserAuthPost(
      userRegistrationSchema: UserRegistrationSchema,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(configuration).registerUserAuthPost(
        userRegistrationSchema,
        options
      )(axios, basePath);
    },
    /**
     *
     * @summary Remove Unverified Email
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailAuthUnverifiedEmailDelete(
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(
        configuration
      ).removeUnverifiedEmailAuthUnverifiedEmailDelete(xToken, options)(
        axios,
        basePath
      );
    },
    /**
     *
     * @summary Resend Email Verification Token
     * @param {BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost} bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
      bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost: BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
      options?: any
    ): AxiosPromise<InstructionsHasBeenSent> {
      return AuthApiFp(
        configuration
      ).resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
        bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Profile
     * @param {string} xToken
     * @param {UpdateCurrentUserProfile} [updateCurrentUserProfile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileAuthUpdateProfilePut(
      xToken: string,
      updateCurrentUserProfile?: UpdateCurrentUserProfile,
      options?: any
    ): AxiosPromise<object> {
      return AuthApiFp(configuration).updateProfileAuthUpdateProfilePut(
        xToken,
        updateCurrentUserProfile,
        options
      )(axios, basePath);
    },
  };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
  /**
   *
   * @summary Admin Login
   * @param {BodyAdminLoginAuthAdminLoginPost} bodyAdminLoginAuthAdminLoginPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  adminLoginAuthAdminLoginPost(
    bodyAdminLoginAuthAdminLoginPost: BodyAdminLoginAuthAdminLoginPost,
    options?: any
  ): AxiosPromise<LoginOutputSchema>;

  /**
   *
   * @summary Change Email
   * @param {string} xToken
   * @param {BodyChangeEmailAuthChangeEmailPut} bodyChangeEmailAuthChangeEmailPut
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  changeEmailAuthChangeEmailPut(
    xToken: string,
    bodyChangeEmailAuthChangeEmailPut: BodyChangeEmailAuthChangeEmailPut,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    User changes her/his own password by providing credentials or tokens.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Change Password
   * @param {string} xToken
   * @param {BodyChangePasswordAuthChangePasswordPost} bodyChangePasswordAuthChangePasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  changePasswordAuthChangePasswordPost(
    xToken: string,
    bodyChangePasswordAuthChangePasswordPost: BodyChangePasswordAuthChangePasswordPost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint will get called when user clicks on reset password token. From here user will be redirected to frontend.  Frontend should serve ``{base_front_url}/resetpassword`` route for this purpose. Based on validation result redirection URL will contain following query parameters: - Valid token: **token={token}&status=Valid** - Invalid token: **token={token}&status=Invalid** - Expired token: **token={token}&status=Expired&email={urlencoded-email}**  **URL encoded email example**: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
   * @summary Check Reset Password Token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  checkResetPasswordTokenAuthCheckResetPasswordTokenGet(
    token: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * Gets a token and sets email verification flag as True  Note: The token can be used only once, if the procedure failed then user should request for a new token.  At the end redirects to frontend.  At the front side two path should handle the redirection. - For success: **{base_front_url}/verificationsuccess** - For failure: **{base_front_url}/verificationfailure**  ``Note:`` In failure case if token was expired, user email will be passed in the querystrings. **{base_front_url}/verificationfailure?email=urlencoded_email**.  ``URL encoded email example``: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
   * @summary Confirm Email
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  confirmEmailAuthConfirmEmailGet(
    token: string,
    options?: any
  ): AxiosPromise<void>;

  /**
   * Provide the token sent to the user\'s email and a new password, if the token is valid one password will be changed.
   * @summary Confirm Reset Password
   * @param {string} token
   * @param {BodyConfirmResetPasswordAuthConfirmResetPasswordPost} bodyConfirmResetPasswordAuthConfirmResetPasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  confirmResetPasswordAuthConfirmResetPasswordPost(
    token: string,
    bodyConfirmResetPasswordAuthConfirmResetPasswordPost: BodyConfirmResetPasswordAuthConfirmResetPasswordPost,
    options?: any
  ): AxiosPromise<object>;

  /**
   *
   * @summary Customer Login
   * @param {BodyCustomerLoginAuthCustomerLoginPost} bodyCustomerLoginAuthCustomerLoginPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  customerLoginAuthCustomerLoginPost(
    bodyCustomerLoginAuthCustomerLoginPost: BodyCustomerLoginAuthCustomerLoginPost,
    options?: any
  ): AxiosPromise<LoginOutputSchema>;

  /**
   *
   * @summary Forgot Password
   * @param {BodyForgotPasswordAuthForgotPasswordPost} bodyForgotPasswordAuthForgotPasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  forgotPasswordAuthForgotPasswordPost(
    bodyForgotPasswordAuthForgotPasswordPost: BodyForgotPasswordAuthForgotPasswordPost,
    options?: any
  ): AxiosPromise<InstructionsHasBeenSent>;

  /**
   * Use profile/user-info instead.
   * @summary Get Current User Info
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  getCurrentUserInfoAuthUserInfoGet(
    xToken: string,
    options?: any
  ): AxiosPromise<CurrentUserInfoSchema>;

  /**
   * Provide your refresh token at header to gain a new pair of access and refresh tokens.   This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Refresh Token
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  refreshTokenAuthRefreshTokenPost(
    xToken: string,
    options?: any
  ): AxiosPromise<LoginOutputSchema>;

  /**
   *
   * @summary Register User
   * @param {UserRegistrationSchema} userRegistrationSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  registerUserAuthPost(
    userRegistrationSchema: UserRegistrationSchema,
    options?: any
  ): AxiosPromise<object>;

  /**
   *
   * @summary Remove Unverified Email
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  removeUnverifiedEmailAuthUnverifiedEmailDelete(
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *
   * @summary Resend Email Verification Token
   * @param {BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost} bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
    bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost: BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
    options?: any
  ): AxiosPromise<InstructionsHasBeenSent>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Update Profile
   * @param {string} xToken
   * @param {UpdateCurrentUserProfile} [updateCurrentUserProfile]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  updateProfileAuthUpdateProfilePut(
    xToken: string,
    updateCurrentUserProfile?: UpdateCurrentUserProfile,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
  /**
   *
   * @summary Admin Login
   * @param {BodyAdminLoginAuthAdminLoginPost} bodyAdminLoginAuthAdminLoginPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public adminLoginAuthAdminLoginPost(
    bodyAdminLoginAuthAdminLoginPost: BodyAdminLoginAuthAdminLoginPost,
    options?: any
  ) {
    return AuthApiFp(this.configuration).adminLoginAuthAdminLoginPost(
      bodyAdminLoginAuthAdminLoginPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Change Email
   * @param {string} xToken
   * @param {BodyChangeEmailAuthChangeEmailPut} bodyChangeEmailAuthChangeEmailPut
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public changeEmailAuthChangeEmailPut(
    xToken: string,
    bodyChangeEmailAuthChangeEmailPut: BodyChangeEmailAuthChangeEmailPut,
    options?: any
  ) {
    return AuthApiFp(this.configuration).changeEmailAuthChangeEmailPut(
      xToken,
      bodyChangeEmailAuthChangeEmailPut,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    User changes her/his own password by providing credentials or tokens.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Change Password
   * @param {string} xToken
   * @param {BodyChangePasswordAuthChangePasswordPost} bodyChangePasswordAuthChangePasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public changePasswordAuthChangePasswordPost(
    xToken: string,
    bodyChangePasswordAuthChangePasswordPost: BodyChangePasswordAuthChangePasswordPost,
    options?: any
  ) {
    return AuthApiFp(this.configuration).changePasswordAuthChangePasswordPost(
      xToken,
      bodyChangePasswordAuthChangePasswordPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint will get called when user clicks on reset password token. From here user will be redirected to frontend.  Frontend should serve ``{base_front_url}/resetpassword`` route for this purpose. Based on validation result redirection URL will contain following query parameters: - Valid token: **token={token}&status=Valid** - Invalid token: **token={token}&status=Invalid** - Expired token: **token={token}&status=Expired&email={urlencoded-email}**  **URL encoded email example**: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
   * @summary Check Reset Password Token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public checkResetPasswordTokenAuthCheckResetPasswordTokenGet(
    token: string,
    options?: any
  ) {
    return AuthApiFp(
      this.configuration
    ).checkResetPasswordTokenAuthCheckResetPasswordTokenGet(token, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Gets a token and sets email verification flag as True  Note: The token can be used only once, if the procedure failed then user should request for a new token.  At the end redirects to frontend.  At the front side two path should handle the redirection. - For success: **{base_front_url}/verificationsuccess** - For failure: **{base_front_url}/verificationfailure**  ``Note:`` In failure case if token was expired, user email will be passed in the querystrings. **{base_front_url}/verificationfailure?email=urlencoded_email**.  ``URL encoded email example``: \"john_doe+customer@gmail.com\" will be converted to \"john_doe%2Bcustomer%40gmail.com\".
   * @summary Confirm Email
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public confirmEmailAuthConfirmEmailGet(token: string, options?: any) {
    return AuthApiFp(this.configuration).confirmEmailAuthConfirmEmailGet(
      token,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Provide the token sent to the user\'s email and a new password, if the token is valid one password will be changed.
   * @summary Confirm Reset Password
   * @param {string} token
   * @param {BodyConfirmResetPasswordAuthConfirmResetPasswordPost} bodyConfirmResetPasswordAuthConfirmResetPasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public confirmResetPasswordAuthConfirmResetPasswordPost(
    token: string,
    bodyConfirmResetPasswordAuthConfirmResetPasswordPost: BodyConfirmResetPasswordAuthConfirmResetPasswordPost,
    options?: any
  ) {
    return AuthApiFp(
      this.configuration
    ).confirmResetPasswordAuthConfirmResetPasswordPost(
      token,
      bodyConfirmResetPasswordAuthConfirmResetPasswordPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Customer Login
   * @param {BodyCustomerLoginAuthCustomerLoginPost} bodyCustomerLoginAuthCustomerLoginPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public customerLoginAuthCustomerLoginPost(
    bodyCustomerLoginAuthCustomerLoginPost: BodyCustomerLoginAuthCustomerLoginPost,
    options?: any
  ) {
    return AuthApiFp(this.configuration).customerLoginAuthCustomerLoginPost(
      bodyCustomerLoginAuthCustomerLoginPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Forgot Password
   * @param {BodyForgotPasswordAuthForgotPasswordPost} bodyForgotPasswordAuthForgotPasswordPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public forgotPasswordAuthForgotPasswordPost(
    bodyForgotPasswordAuthForgotPasswordPost: BodyForgotPasswordAuthForgotPasswordPost,
    options?: any
  ) {
    return AuthApiFp(this.configuration).forgotPasswordAuthForgotPasswordPost(
      bodyForgotPasswordAuthForgotPasswordPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Use profile/user-info instead.
   * @summary Get Current User Info
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public getCurrentUserInfoAuthUserInfoGet(xToken: string, options?: any) {
    return AuthApiFp(this.configuration).getCurrentUserInfoAuthUserInfoGet(
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Provide your refresh token at header to gain a new pair of access and refresh tokens.   This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Refresh Token
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshTokenAuthRefreshTokenPost(xToken: string, options?: any) {
    return AuthApiFp(this.configuration).refreshTokenAuthRefreshTokenPost(
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Register User
   * @param {UserRegistrationSchema} userRegistrationSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public registerUserAuthPost(
    userRegistrationSchema: UserRegistrationSchema,
    options?: any
  ) {
    return AuthApiFp(this.configuration).registerUserAuthPost(
      userRegistrationSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Remove Unverified Email
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public removeUnverifiedEmailAuthUnverifiedEmailDelete(
    xToken: string,
    options?: any
  ) {
    return AuthApiFp(
      this.configuration
    ).removeUnverifiedEmailAuthUnverifiedEmailDelete(xToken, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   *
   * @summary Resend Email Verification Token
   * @param {BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost} bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
    bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost: BodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
    options?: any
  ) {
    return AuthApiFp(
      this.configuration
    ).resendEmailVerificationTokenAuthResendEmailVerificationTokenPost(
      bodyResendEmailVerificationTokenAuthResendEmailVerificationTokenPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Update Profile
   * @param {string} xToken
   * @param {UpdateCurrentUserProfile} [updateCurrentUserProfile]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public updateProfileAuthUpdateProfilePut(
    xToken: string,
    updateCurrentUserProfile?: UpdateCurrentUserProfile,
    options?: any
  ) {
    return AuthApiFp(this.configuration).updateProfileAuthUpdateProfilePut(
      xToken,
      updateCurrentUserProfile,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * CouponsApi - axios parameter creator
 * @export
 */
export const CouponsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCouponCouponsCouponIdActivatePost(
      couponId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'couponId' is not null or undefined
      if (couponId === null || couponId === undefined) {
        throw new RequiredError(
          "couponId",
          "Required parameter couponId was null or undefined when calling activateCouponCouponsCouponIdActivatePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling activateCouponCouponsCouponIdActivatePost."
        );
      }
      const localVarPath = `/coupons/{couponId}/activate`.replace(
        `{${"couponId"}}`,
        encodeURIComponent(String(couponId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Coupon
     * @param {string} xToken
     * @param {CreateCouponInputSchema} createCouponInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCouponCouponsPost(
      xToken: string,
      createCouponInputSchema: CreateCouponInputSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling addCouponCouponsPost."
        );
      }
      // verify required parameter 'createCouponInputSchema' is not null or undefined
      if (
        createCouponInputSchema === null ||
        createCouponInputSchema === undefined
      ) {
        throw new RequiredError(
          "createCouponInputSchema",
          "Required parameter createCouponInputSchema was null or undefined when calling addCouponCouponsPost."
        );
      }
      const localVarPath = `/coupons`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof createCouponInputSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createCouponInputSchema !== undefined ? createCouponInputSchema : {}
          )
        : createCouponInputSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Customer To Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost} bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCustomerToCouponCouponsCouponIdAddCustomerPost(
      couponId: number,
      xToken: string,
      bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost: BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'couponId' is not null or undefined
      if (couponId === null || couponId === undefined) {
        throw new RequiredError(
          "couponId",
          "Required parameter couponId was null or undefined when calling addCustomerToCouponCouponsCouponIdAddCustomerPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling addCustomerToCouponCouponsCouponIdAddCustomerPost."
        );
      }
      // verify required parameter 'bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost' is not null or undefined
      if (
        bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost === null ||
        bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost === undefined
      ) {
        throw new RequiredError(
          "bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost",
          "Required parameter bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost was null or undefined when calling addCustomerToCouponCouponsCouponIdAddCustomerPost."
        );
      }
      const localVarPath = `/coupons/{couponId}/add-customer`.replace(
        `{${"couponId"}}`,
        encodeURIComponent(String(couponId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost !== undefined
              ? bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
              : {}
          )
        : bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCouponCouponsCouponIdDeactivatePost(
      couponId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'couponId' is not null or undefined
      if (couponId === null || couponId === undefined) {
        throw new RequiredError(
          "couponId",
          "Required parameter couponId was null or undefined when calling deactivateCouponCouponsCouponIdDeactivatePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling deactivateCouponCouponsCouponIdDeactivatePost."
        );
      }
      const localVarPath = `/coupons/{couponId}/deactivate`.replace(
        `{${"couponId"}}`,
        encodeURIComponent(String(couponId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Get Coupon Types
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCouponTypesCouponsTypesGet(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getCouponTypesCouponsTypesGet."
        );
      }
      const localVarPath = `/coupons/types`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Coupons
     * @param {string} xToken
     * @param {string} [code]
     * @param {number} [page]
     * @param {boolean} [availablesOnly]
     * @param {CouponTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCouponsCouponsGet(
      xToken: string,
      code?: string,
      page?: number,
      availablesOnly?: boolean,
      type?: CouponTypeEnum,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listCouponsCouponsGet."
        );
      }
      const localVarPath = `/coupons`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (code !== undefined) {
        localVarQueryParameter["code"] = code;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (availablesOnly !== undefined) {
        localVarQueryParameter["AvailablesOnly"] = availablesOnly;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Customer From Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete} bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
      couponId: number,
      xToken: string,
      bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete: BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'couponId' is not null or undefined
      if (couponId === null || couponId === undefined) {
        throw new RequiredError(
          "couponId",
          "Required parameter couponId was null or undefined when calling removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete."
        );
      }
      // verify required parameter 'bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete' is not null or undefined
      if (
        bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete ===
          null ||
        bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete ===
          undefined
      ) {
        throw new RequiredError(
          "bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete",
          "Required parameter bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete was null or undefined when calling removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete."
        );
      }
      const localVarPath = `/coupons/{couponId}/remove-customer`.replace(
        `{${"couponId"}}`,
        encodeURIComponent(String(couponId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete !==
              undefined
              ? bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
              : {}
          )
        : bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CouponsApi - functional programming interface
 * @export
 */
export const CouponsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCouponCouponsCouponIdActivatePost(
      couponId: number,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).activateCouponCouponsCouponIdActivatePost(couponId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Coupon
     * @param {string} xToken
     * @param {CreateCouponInputSchema} createCouponInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCouponCouponsPost(
      xToken: string,
      createCouponInputSchema: CreateCouponInputSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CouponSchema> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).addCouponCouponsPost(xToken, createCouponInputSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Customer To Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost} bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCustomerToCouponCouponsCouponIdAddCustomerPost(
      couponId: number,
      xToken: string,
      bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost: BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).addCustomerToCouponCouponsCouponIdAddCustomerPost(
        couponId,
        xToken,
        bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCouponCouponsCouponIdDeactivatePost(
      couponId: number,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).deactivateCouponCouponsCouponIdDeactivatePost(
        couponId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Get Coupon Types
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCouponTypesCouponsTypesGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CouponTypesEndpointOutput> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).getCouponTypesCouponsTypesGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Coupons
     * @param {string} xToken
     * @param {string} [code]
     * @param {number} [page]
     * @param {boolean} [availablesOnly]
     * @param {CouponTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCouponsCouponsGet(
      xToken: string,
      code?: string,
      page?: number,
      availablesOnly?: boolean,
      type?: CouponTypeEnum,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CouponPaginatedListSchema> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).listCouponsCouponsGet(
        xToken,
        code,
        page,
        availablesOnly,
        type,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Customer From Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete} bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
      couponId: number,
      xToken: string,
      bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete: BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CouponsApiAxiosParamCreator(
        configuration
      ).removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
        couponId,
        xToken,
        bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * CouponsApi - factory interface
 * @export
 */
export const CouponsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCouponCouponsCouponIdActivatePost(
      couponId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CouponsApiFp(
        configuration
      ).activateCouponCouponsCouponIdActivatePost(
        couponId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Coupon
     * @param {string} xToken
     * @param {CreateCouponInputSchema} createCouponInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCouponCouponsPost(
      xToken: string,
      createCouponInputSchema: CreateCouponInputSchema,
      options?: any
    ): AxiosPromise<CouponSchema> {
      return CouponsApiFp(configuration).addCouponCouponsPost(
        xToken,
        createCouponInputSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Customer To Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost} bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCustomerToCouponCouponsCouponIdAddCustomerPost(
      couponId: number,
      xToken: string,
      bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost: BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
      options?: any
    ): AxiosPromise<object> {
      return CouponsApiFp(
        configuration
      ).addCustomerToCouponCouponsCouponIdAddCustomerPost(
        couponId,
        xToken,
        bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCouponCouponsCouponIdDeactivatePost(
      couponId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CouponsApiFp(
        configuration
      ).deactivateCouponCouponsCouponIdDeactivatePost(
        couponId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Get Coupon Types
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCouponTypesCouponsTypesGet(
      xToken: string,
      options?: any
    ): AxiosPromise<CouponTypesEndpointOutput> {
      return CouponsApiFp(configuration).getCouponTypesCouponsTypesGet(
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Coupons
     * @param {string} xToken
     * @param {string} [code]
     * @param {number} [page]
     * @param {boolean} [availablesOnly]
     * @param {CouponTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCouponsCouponsGet(
      xToken: string,
      code?: string,
      page?: number,
      availablesOnly?: boolean,
      type?: CouponTypeEnum,
      options?: any
    ): AxiosPromise<CouponPaginatedListSchema> {
      return CouponsApiFp(configuration).listCouponsCouponsGet(
        xToken,
        code,
        page,
        availablesOnly,
        type,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Customer From Coupon
     * @param {number} couponId
     * @param {string} xToken
     * @param {BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete} bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
      couponId: number,
      xToken: string,
      bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete: BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
      options?: any
    ): AxiosPromise<object> {
      return CouponsApiFp(
        configuration
      ).removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
        couponId,
        xToken,
        bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
        options
      )(axios, basePath);
    },
  };
};

/**
 * CouponsApi - interface
 * @export
 * @interface CouponsApi
 */
export interface CouponsApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Activate Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  activateCouponCouponsCouponIdActivatePost(
    couponId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Coupon
   * @param {string} xToken
   * @param {CreateCouponInputSchema} createCouponInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  addCouponCouponsPost(
    xToken: string,
    createCouponInputSchema: CreateCouponInputSchema,
    options?: any
  ): AxiosPromise<CouponSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Customer To Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost} bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  addCustomerToCouponCouponsCouponIdAddCustomerPost(
    couponId: number,
    xToken: string,
    bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost: BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Deactivate Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  deactivateCouponCouponsCouponIdDeactivatePost(
    couponId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Get Coupon Types
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  getCouponTypesCouponsTypesGet(
    xToken: string,
    options?: any
  ): AxiosPromise<CouponTypesEndpointOutput>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary List Coupons
   * @param {string} xToken
   * @param {string} [code]
   * @param {number} [page]
   * @param {boolean} [availablesOnly]
   * @param {CouponTypeEnum} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  listCouponsCouponsGet(
    xToken: string,
    code?: string,
    page?: number,
    availablesOnly?: boolean,
    type?: CouponTypeEnum,
    options?: any
  ): AxiosPromise<CouponPaginatedListSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Remove Customer From Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete} bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApiInterface
   */
  removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
    couponId: number,
    xToken: string,
    bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete: BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * CouponsApi - object-oriented interface
 * @export
 * @class CouponsApi
 * @extends {BaseAPI}
 */
export class CouponsApi extends BaseAPI implements CouponsApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Activate Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public activateCouponCouponsCouponIdActivatePost(
    couponId: number,
    xToken: string,
    options?: any
  ) {
    return CouponsApiFp(
      this.configuration
    ).activateCouponCouponsCouponIdActivatePost(
      couponId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Coupon
   * @param {string} xToken
   * @param {CreateCouponInputSchema} createCouponInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public addCouponCouponsPost(
    xToken: string,
    createCouponInputSchema: CreateCouponInputSchema,
    options?: any
  ) {
    return CouponsApiFp(this.configuration).addCouponCouponsPost(
      xToken,
      createCouponInputSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Customer To Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost} bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public addCustomerToCouponCouponsCouponIdAddCustomerPost(
    couponId: number,
    xToken: string,
    bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost: BodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
    options?: any
  ) {
    return CouponsApiFp(
      this.configuration
    ).addCustomerToCouponCouponsCouponIdAddCustomerPost(
      couponId,
      xToken,
      bodyAddCustomerToCouponCouponsCouponIdAddCustomerPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Deactivate Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public deactivateCouponCouponsCouponIdDeactivatePost(
    couponId: number,
    xToken: string,
    options?: any
  ) {
    return CouponsApiFp(
      this.configuration
    ).deactivateCouponCouponsCouponIdDeactivatePost(
      couponId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Get Coupon Types
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public getCouponTypesCouponsTypesGet(xToken: string, options?: any) {
    return CouponsApiFp(this.configuration).getCouponTypesCouponsTypesGet(
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary List Coupons
   * @param {string} xToken
   * @param {string} [code]
   * @param {number} [page]
   * @param {boolean} [availablesOnly]
   * @param {CouponTypeEnum} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public listCouponsCouponsGet(
    xToken: string,
    code?: string,
    page?: number,
    availablesOnly?: boolean,
    type?: CouponTypeEnum,
    options?: any
  ) {
    return CouponsApiFp(this.configuration).listCouponsCouponsGet(
      xToken,
      code,
      page,
      availablesOnly,
      type,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Remove Customer From Coupon
   * @param {number} couponId
   * @param {string} xToken
   * @param {BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete} bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CouponsApi
   */
  public removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
    couponId: number,
    xToken: string,
    bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete: BodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
    options?: any
  ) {
    return CouponsApiFp(
      this.configuration
    ).removeCustomerFromCouponCouponsCouponIdRemoveCustomerDelete(
      couponId,
      xToken,
      bodyRemoveCustomerFromCouponCouponsCouponIdRemoveCustomerDelete,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCustomerCustomersCustomerIdActivatePost(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling activateCustomerCustomersCustomerIdActivatePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling activateCustomerCustomersCustomerIdActivatePost."
        );
      }
      const localVarPath = `/customers/{customerId}/activate`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Note For Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAddNoteForCustomerCustomersCustomerIdNotePost} bodyAddNoteForCustomerCustomersCustomerIdNotePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNoteForCustomerCustomersCustomerIdNotePost(
      customerId: string,
      xToken: string,
      bodyAddNoteForCustomerCustomersCustomerIdNotePost: BodyAddNoteForCustomerCustomersCustomerIdNotePost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling addNoteForCustomerCustomersCustomerIdNotePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling addNoteForCustomerCustomersCustomerIdNotePost."
        );
      }
      // verify required parameter 'bodyAddNoteForCustomerCustomersCustomerIdNotePost' is not null or undefined
      if (
        bodyAddNoteForCustomerCustomersCustomerIdNotePost === null ||
        bodyAddNoteForCustomerCustomersCustomerIdNotePost === undefined
      ) {
        throw new RequiredError(
          "bodyAddNoteForCustomerCustomersCustomerIdNotePost",
          "Required parameter bodyAddNoteForCustomerCustomersCustomerIdNotePost was null or undefined when calling addNoteForCustomerCustomersCustomerIdNotePost."
        );
      }
      const localVarPath = `/customers/{customerId}/note`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyAddNoteForCustomerCustomersCustomerIdNotePost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyAddNoteForCustomerCustomersCustomerIdNotePost !== undefined
              ? bodyAddNoteForCustomerCustomersCustomerIdNotePost
              : {}
          )
        : bodyAddNoteForCustomerCustomersCustomerIdNotePost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Adjust Customer Credit
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost} bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
      customerId: string,
      xToken: string,
      bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost: BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling adjustCustomerCreditCustomersCustomerIdAdjustCreditPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling adjustCustomerCreditCustomersCustomerIdAdjustCreditPost."
        );
      }
      // verify required parameter 'bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost' is not null or undefined
      if (
        bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost === null ||
        bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost ===
          undefined
      ) {
        throw new RequiredError(
          "bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost",
          "Required parameter bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost was null or undefined when calling adjustCustomerCreditCustomersCustomerIdAdjustCreditPost."
        );
      }
      const localVarPath = `/customers/{customerId}/adjust-credit`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost !==
              undefined
              ? bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
              : {}
          )
        : bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Adds an unverified email for the customer, then sends a token to the email.    Whenever customer clicks on that token, the unverified email will be set as main email.     The endpoint also can be used as endpoint for resending verification tokens to customers unverified email.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Change Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyChangeEmailCustomersCustomerIdChangeEmailPost} bodyChangeEmailCustomersCustomerIdChangeEmailPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailCustomersCustomerIdChangeEmailPost(
      customerId: string,
      xToken: string,
      bodyChangeEmailCustomersCustomerIdChangeEmailPost: BodyChangeEmailCustomersCustomerIdChangeEmailPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling changeEmailCustomersCustomerIdChangeEmailPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling changeEmailCustomersCustomerIdChangeEmailPost."
        );
      }
      // verify required parameter 'bodyChangeEmailCustomersCustomerIdChangeEmailPost' is not null or undefined
      if (
        bodyChangeEmailCustomersCustomerIdChangeEmailPost === null ||
        bodyChangeEmailCustomersCustomerIdChangeEmailPost === undefined
      ) {
        throw new RequiredError(
          "bodyChangeEmailCustomersCustomerIdChangeEmailPost",
          "Required parameter bodyChangeEmailCustomersCustomerIdChangeEmailPost was null or undefined when calling changeEmailCustomersCustomerIdChangeEmailPost."
        );
      }
      const localVarPath = `/customers/{customerId}/change-email`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyChangeEmailCustomersCustomerIdChangeEmailPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyChangeEmailCustomersCustomerIdChangeEmailPost !== undefined
              ? bodyChangeEmailCustomersCustomerIdChangeEmailPost
              : {}
          )
        : bodyChangeEmailCustomersCustomerIdChangeEmailPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Check Current Customer Balance
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
      customerId: string,
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost."
        );
      }
      // verify required parameter 'bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost' is not null or undefined
      if (
        bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost ===
          null ||
        bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost ===
          undefined
      ) {
        throw new RequiredError(
          "bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost",
          "Required parameter bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost was null or undefined when calling checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost."
        );
      }
      const localVarPath = `/customers/{customerId}/check-balance`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customer_id"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost !==
              undefined
              ? bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
              : {}
          )
        : bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost ||
          "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Check Current Customer Balance
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling checkCurrentCustomerBalanceCustomersMeCheckBalancePost."
        );
      }
      // verify required parameter 'bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost' is not null or undefined
      if (
        bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost === null ||
        bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost === undefined
      ) {
        throw new RequiredError(
          "bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost",
          "Required parameter bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost was null or undefined when calling checkCurrentCustomerBalanceCustomersMeCheckBalancePost."
        );
      }
      const localVarPath = `/customers/me/check-balance`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost !==
          "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost !==
              undefined
              ? bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
              : {}
          )
        : bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Billing Info
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerBillingInfoCustomersCustomerIdBillingDataGet(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling customerBillingInfoCustomersCustomerIdBillingDataGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling customerBillingInfoCustomersCustomerIdBillingDataGet."
        );
      }
      const localVarPath = `/customers/{customerId}/billing-data`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Details
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDetailsCustomersCustomerIdGet(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling customerDetailsCustomersCustomerIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling customerDetailsCustomersCustomerIdGet."
        );
      }
      const localVarPath = `/customers/{customerId}`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCustomerCustomersCustomerIdDeactivatePost(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling deactivateCustomerCustomersCustomerIdDeactivatePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling deactivateCustomerCustomersCustomerIdDeactivatePost."
        );
      }
      const localVarPath = `/customers/{customerId}/deactivate`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Delete Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomerCustomersCustomerIdDelete(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling deleteCustomerCustomersCustomerIdDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling deleteCustomerCustomersCustomerIdDelete."
        );
      }
      const localVarPath = `/customers/{customerId}`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Disables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Disable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete."
        );
      }
      const localVarPath = `/customers/{customerId}/override-suspension`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customer_id"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Enables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Enable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost."
        );
      }
      const localVarPath = `/customers/{customerId}/override-suspension`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customer_id"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Of Customers
     * @param {string} xToken
     * @param {string} [fullname]
     * @param {string} [email]
     * @param {string} [customerId]
     * @param {number} [start] Filter from timestamp
     * @param {number} [end] Filter to timestamp
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfCustomersCustomersGet(
      xToken: string,
      fullname?: string,
      email?: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listOfCustomersCustomersGet."
        );
      }
      const localVarPath = `/customers`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (fullname !== undefined) {
        localVarQueryParameter["fullname"] = fullname;
      }

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = end;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Remove unverified email for the customer.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Unverified Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete."
        );
      }
      const localVarPath = `/customers/{customerId}/unverified-email`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Send Reset Password Token
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling sendResetPasswordTokenCustomersCustomerIdResetPasswordPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling sendResetPasswordTokenCustomersCustomerIdResetPasswordPost."
        );
      }
      const localVarPath = `/customers/{customerId}/reset-password`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodySuspendCustomerCustomersCustomerIdSuspendPost} bodySuspendCustomerCustomersCustomerIdSuspendPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendCustomerCustomersCustomerIdSuspendPost(
      customerId: string,
      xToken: string,
      bodySuspendCustomerCustomersCustomerIdSuspendPost: BodySuspendCustomerCustomersCustomerIdSuspendPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling suspendCustomerCustomersCustomerIdSuspendPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling suspendCustomerCustomersCustomerIdSuspendPost."
        );
      }
      // verify required parameter 'bodySuspendCustomerCustomersCustomerIdSuspendPost' is not null or undefined
      if (
        bodySuspendCustomerCustomersCustomerIdSuspendPost === null ||
        bodySuspendCustomerCustomersCustomerIdSuspendPost === undefined
      ) {
        throw new RequiredError(
          "bodySuspendCustomerCustomersCustomerIdSuspendPost",
          "Required parameter bodySuspendCustomerCustomersCustomerIdSuspendPost was null or undefined when calling suspendCustomerCustomersCustomerIdSuspendPost."
        );
      }
      const localVarPath = `/customers/{customerId}/suspend`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodySuspendCustomerCustomersCustomerIdSuspendPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodySuspendCustomerCustomersCustomerIdSuspendPost !== undefined
              ? bodySuspendCustomerCustomersCustomerIdSuspendPost
              : {}
          )
        : bodySuspendCustomerCustomersCustomerIdSuspendPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Unsuspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsuspendCustomerCustomersCustomerIdUnsuspendPost(
      customerId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling unsuspendCustomerCustomersCustomerIdUnsuspendPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling unsuspendCustomerCustomersCustomerIdUnsuspendPost."
        );
      }
      const localVarPath = `/customers/{customerId}/unsuspend`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Update Customer Profile
     * @param {string} customerId
     * @param {string} xToken
     * @param {CustomerProfileUpdateInputSchema} [customerProfileUpdateInputSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
      customerId: string,
      xToken: string,
      customerProfileUpdateInputSchema?: CustomerProfileUpdateInputSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'customerId' is not null or undefined
      if (customerId === null || customerId === undefined) {
        throw new RequiredError(
          "customerId",
          "Required parameter customerId was null or undefined when calling updateCustomerProfileCustomersCustomerIdUpdateProfilePut."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling updateCustomerProfileCustomersCustomerIdUpdateProfilePut."
        );
      }
      const localVarPath = `/customers/{customerId}/update-profile`.replace(
        `{${"customerId"}}`,
        encodeURIComponent(String(customerId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof customerProfileUpdateInputSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            customerProfileUpdateInputSchema !== undefined
              ? customerProfileUpdateInputSchema
              : {}
          )
        : customerProfileUpdateInputSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCustomerCustomersCustomerIdActivatePost(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).activateCustomerCustomersCustomerIdActivatePost(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Note For Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAddNoteForCustomerCustomersCustomerIdNotePost} bodyAddNoteForCustomerCustomersCustomerIdNotePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNoteForCustomerCustomersCustomerIdNotePost(
      customerId: string,
      xToken: string,
      bodyAddNoteForCustomerCustomersCustomerIdNotePost: BodyAddNoteForCustomerCustomersCustomerIdNotePost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).addNoteForCustomerCustomersCustomerIdNotePost(
        customerId,
        xToken,
        bodyAddNoteForCustomerCustomersCustomerIdNotePost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Adjust Customer Credit
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost} bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
      customerId: string,
      xToken: string,
      bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost: BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
        customerId,
        xToken,
        bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Adds an unverified email for the customer, then sends a token to the email.    Whenever customer clicks on that token, the unverified email will be set as main email.     The endpoint also can be used as endpoint for resending verification tokens to customers unverified email.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Change Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyChangeEmailCustomersCustomerIdChangeEmailPost} bodyChangeEmailCustomersCustomerIdChangeEmailPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailCustomersCustomerIdChangeEmailPost(
      customerId: string,
      xToken: string,
      bodyChangeEmailCustomersCustomerIdChangeEmailPost: BodyChangeEmailCustomersCustomerIdChangeEmailPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstructionsHasBeenSent> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).changeEmailCustomersCustomerIdChangeEmailPost(
        customerId,
        xToken,
        bodyChangeEmailCustomersCustomerIdChangeEmailPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Check Current Customer Balance
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
      customerId: string,
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
        customerId,
        xToken,
        bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Check Current Customer Balance
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
        xToken,
        bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Billing Info
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerBillingInfoCustomersCustomerIdBillingDataGet(
      customerId: string,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CustomerBillingDetailSchema> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).customerBillingInfoCustomersCustomerIdBillingDataGet(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Details
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDetailsCustomersCustomerIdGet(
      customerId: string,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CustomerDetailOutputSchema> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).customerDetailsCustomersCustomerIdGet(customerId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCustomerCustomersCustomerIdDeactivatePost(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).deactivateCustomerCustomersCustomerIdDeactivatePost(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Delete Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomerCustomersCustomerIdDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).deleteCustomerCustomersCustomerIdDelete(customerId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Disables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Disable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Enables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Enable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Of Customers
     * @param {string} xToken
     * @param {string} [fullname]
     * @param {string} [email]
     * @param {string} [customerId]
     * @param {number} [start] Filter from timestamp
     * @param {number} [end] Filter to timestamp
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfCustomersCustomersGet(
      xToken: string,
      fullname?: string,
      email?: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CustomerListOutputSchema> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).listOfCustomersCustomersGet(
        xToken,
        fullname,
        email,
        customerId,
        start,
        end,
        page,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Remove unverified email for the customer.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Unverified Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Send Reset Password Token
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
      customerId: string,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstructionsHasBeenSent> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodySuspendCustomerCustomersCustomerIdSuspendPost} bodySuspendCustomerCustomersCustomerIdSuspendPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendCustomerCustomersCustomerIdSuspendPost(
      customerId: string,
      xToken: string,
      bodySuspendCustomerCustomersCustomerIdSuspendPost: BodySuspendCustomerCustomersCustomerIdSuspendPost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).suspendCustomerCustomersCustomerIdSuspendPost(
        customerId,
        xToken,
        bodySuspendCustomerCustomersCustomerIdSuspendPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Unsuspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsuspendCustomerCustomersCustomerIdUnsuspendPost(
      customerId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).unsuspendCustomerCustomersCustomerIdUnsuspendPost(
        customerId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Update Customer Profile
     * @param {string} customerId
     * @param {string} xToken
     * @param {CustomerProfileUpdateInputSchema} [customerProfileUpdateInputSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
      customerId: string,
      xToken: string,
      customerProfileUpdateInputSchema?: CustomerProfileUpdateInputSchema,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = CustomersApiAxiosParamCreator(
        configuration
      ).updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
        customerId,
        xToken,
        customerProfileUpdateInputSchema,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Activate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateCustomerCustomersCustomerIdActivatePost(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).activateCustomerCustomersCustomerIdActivatePost(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Note For Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAddNoteForCustomerCustomersCustomerIdNotePost} bodyAddNoteForCustomerCustomersCustomerIdNotePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNoteForCustomerCustomersCustomerIdNotePost(
      customerId: string,
      xToken: string,
      bodyAddNoteForCustomerCustomersCustomerIdNotePost: BodyAddNoteForCustomerCustomersCustomerIdNotePost,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).addNoteForCustomerCustomersCustomerIdNotePost(
        customerId,
        xToken,
        bodyAddNoteForCustomerCustomersCustomerIdNotePost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Adjust Customer Credit
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost} bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
      customerId: string,
      xToken: string,
      bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost: BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
        customerId,
        xToken,
        bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
        options
      )(axios, basePath);
    },
    /**
     *    Adds an unverified email for the customer, then sends a token to the email.    Whenever customer clicks on that token, the unverified email will be set as main email.     The endpoint also can be used as endpoint for resending verification tokens to customers unverified email.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Change Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyChangeEmailCustomersCustomerIdChangeEmailPost} bodyChangeEmailCustomersCustomerIdChangeEmailPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeEmailCustomersCustomerIdChangeEmailPost(
      customerId: string,
      xToken: string,
      bodyChangeEmailCustomersCustomerIdChangeEmailPost: BodyChangeEmailCustomersCustomerIdChangeEmailPost,
      options?: any
    ): AxiosPromise<InstructionsHasBeenSent> {
      return CustomersApiFp(
        configuration
      ).changeEmailCustomersCustomerIdChangeEmailPost(
        customerId,
        xToken,
        bodyChangeEmailCustomersCustomerIdChangeEmailPost,
        options
      )(axios, basePath);
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Check Current Customer Balance
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
      customerId: string,
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
        customerId,
        xToken,
        bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
        options
      )(axios, basePath);
    },
    /**
     *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Check Current Customer Balance
     * @param {string} xToken
     * @param {BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
      xToken: string,
      bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
        xToken,
        bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Billing Info
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerBillingInfoCustomersCustomerIdBillingDataGet(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<CustomerBillingDetailSchema> {
      return CustomersApiFp(
        configuration
      ).customerBillingInfoCustomersCustomerIdBillingDataGet(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Customer Details
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDetailsCustomersCustomerIdGet(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<CustomerDetailOutputSchema> {
      return CustomersApiFp(
        configuration
      ).customerDetailsCustomersCustomerIdGet(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Deactivate Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateCustomerCustomersCustomerIdDeactivatePost(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).deactivateCustomerCustomersCustomerIdDeactivatePost(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Delete Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomerCustomersCustomerIdDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).deleteCustomerCustomersCustomerIdDelete(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    Disables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Disable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    Enables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Enable Billing Suspension Override
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary List Of Customers
     * @param {string} xToken
     * @param {string} [fullname]
     * @param {string} [email]
     * @param {string} [customerId]
     * @param {number} [start] Filter from timestamp
     * @param {number} [end] Filter to timestamp
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfCustomersCustomersGet(
      xToken: string,
      fullname?: string,
      email?: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): AxiosPromise<CustomerListOutputSchema> {
      return CustomersApiFp(configuration).listOfCustomersCustomersGet(
        xToken,
        fullname,
        email,
        customerId,
        start,
        end,
        page,
        options
      )(axios, basePath);
    },
    /**
     *    Remove unverified email for the customer.       This endpoint can be used by following group(s):  ``admin``.
     * @summary Remove Unverified Email
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Send Reset Password Token
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<InstructionsHasBeenSent> {
      return CustomersApiFp(
        configuration
      ).sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {BodySuspendCustomerCustomersCustomerIdSuspendPost} bodySuspendCustomerCustomersCustomerIdSuspendPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendCustomerCustomersCustomerIdSuspendPost(
      customerId: string,
      xToken: string,
      bodySuspendCustomerCustomersCustomerIdSuspendPost: BodySuspendCustomerCustomersCustomerIdSuspendPost,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).suspendCustomerCustomersCustomerIdSuspendPost(
        customerId,
        xToken,
        bodySuspendCustomerCustomersCustomerIdSuspendPost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Unsuspend Customer
     * @param {string} customerId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsuspendCustomerCustomersCustomerIdUnsuspendPost(
      customerId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).unsuspendCustomerCustomersCustomerIdUnsuspendPost(
        customerId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Update Customer Profile
     * @param {string} customerId
     * @param {string} xToken
     * @param {CustomerProfileUpdateInputSchema} [customerProfileUpdateInputSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
      customerId: string,
      xToken: string,
      customerProfileUpdateInputSchema?: CustomerProfileUpdateInputSchema,
      options?: any
    ): AxiosPromise<object> {
      return CustomersApiFp(
        configuration
      ).updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
        customerId,
        xToken,
        customerProfileUpdateInputSchema,
        options
      )(axios, basePath);
    },
  };
};

/**
 * CustomersApi - interface
 * @export
 * @interface CustomersApi
 */
export interface CustomersApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Activate Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  activateCustomerCustomersCustomerIdActivatePost(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Note For Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyAddNoteForCustomerCustomersCustomerIdNotePost} bodyAddNoteForCustomerCustomersCustomerIdNotePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  addNoteForCustomerCustomersCustomerIdNotePost(
    customerId: string,
    xToken: string,
    bodyAddNoteForCustomerCustomersCustomerIdNotePost: BodyAddNoteForCustomerCustomersCustomerIdNotePost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Adjust Customer Credit
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost} bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
    customerId: string,
    xToken: string,
    bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost: BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Adds an unverified email for the customer, then sends a token to the email.    Whenever customer clicks on that token, the unverified email will be set as main email.     The endpoint also can be used as endpoint for resending verification tokens to customers unverified email.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Change Email
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyChangeEmailCustomersCustomerIdChangeEmailPost} bodyChangeEmailCustomersCustomerIdChangeEmailPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  changeEmailCustomersCustomerIdChangeEmailPost(
    customerId: string,
    xToken: string,
    bodyChangeEmailCustomersCustomerIdChangeEmailPost: BodyChangeEmailCustomersCustomerIdChangeEmailPost,
    options?: any
  ): AxiosPromise<InstructionsHasBeenSent>;

  /**
   *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Check Current Customer Balance
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
    customerId: string,
    xToken: string,
    bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Check Current Customer Balance
   * @param {string} xToken
   * @param {BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
    xToken: string,
    bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Customer Billing Info
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  customerBillingInfoCustomersCustomerIdBillingDataGet(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<CustomerBillingDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Customer Details
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  customerDetailsCustomersCustomerIdGet(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<CustomerDetailOutputSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Deactivate Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  deactivateCustomerCustomersCustomerIdDeactivatePost(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Delete Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  deleteCustomerCustomersCustomerIdDelete(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Disables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Disable Billing Suspension Override
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Enables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Enable Billing Suspension Override
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary List Of Customers
   * @param {string} xToken
   * @param {string} [fullname]
   * @param {string} [email]
   * @param {string} [customerId]
   * @param {number} [start] Filter from timestamp
   * @param {number} [end] Filter to timestamp
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  listOfCustomersCustomersGet(
    xToken: string,
    fullname?: string,
    email?: string,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ): AxiosPromise<CustomerListOutputSchema>;

  /**
   *    Remove unverified email for the customer.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Remove Unverified Email
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Send Reset Password Token
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<InstructionsHasBeenSent>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Suspend Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodySuspendCustomerCustomersCustomerIdSuspendPost} bodySuspendCustomerCustomersCustomerIdSuspendPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  suspendCustomerCustomersCustomerIdSuspendPost(
    customerId: string,
    xToken: string,
    bodySuspendCustomerCustomersCustomerIdSuspendPost: BodySuspendCustomerCustomersCustomerIdSuspendPost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Unsuspend Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  unsuspendCustomerCustomersCustomerIdUnsuspendPost(
    customerId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Update Customer Profile
   * @param {string} customerId
   * @param {string} xToken
   * @param {CustomerProfileUpdateInputSchema} [customerProfileUpdateInputSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApiInterface
   */
  updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
    customerId: string,
    xToken: string,
    customerProfileUpdateInputSchema?: CustomerProfileUpdateInputSchema,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI implements CustomersApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Activate Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public activateCustomerCustomersCustomerIdActivatePost(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).activateCustomerCustomersCustomerIdActivatePost(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Note For Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyAddNoteForCustomerCustomersCustomerIdNotePost} bodyAddNoteForCustomerCustomersCustomerIdNotePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public addNoteForCustomerCustomersCustomerIdNotePost(
    customerId: string,
    xToken: string,
    bodyAddNoteForCustomerCustomersCustomerIdNotePost: BodyAddNoteForCustomerCustomersCustomerIdNotePost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).addNoteForCustomerCustomersCustomerIdNotePost(
      customerId,
      xToken,
      bodyAddNoteForCustomerCustomersCustomerIdNotePost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Adjust Customer Credit
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost} bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
    customerId: string,
    xToken: string,
    bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost: BodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).adjustCustomerCreditCustomersCustomerIdAdjustCreditPost(
      customerId,
      xToken,
      bodyAdjustCustomerCreditCustomersCustomerIdAdjustCreditPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Adds an unverified email for the customer, then sends a token to the email.    Whenever customer clicks on that token, the unverified email will be set as main email.     The endpoint also can be used as endpoint for resending verification tokens to customers unverified email.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Change Email
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyChangeEmailCustomersCustomerIdChangeEmailPost} bodyChangeEmailCustomersCustomerIdChangeEmailPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public changeEmailCustomersCustomerIdChangeEmailPost(
    customerId: string,
    xToken: string,
    bodyChangeEmailCustomersCustomerIdChangeEmailPost: BodyChangeEmailCustomersCustomerIdChangeEmailPost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).changeEmailCustomersCustomerIdChangeEmailPost(
      customerId,
      xToken,
      bodyChangeEmailCustomersCustomerIdChangeEmailPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Check Current Customer Balance
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
    customerId: string,
    xToken: string,
    bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).checkCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost(
      customerId,
      xToken,
      bodyCheckCurrentCustomerBalanceCustomersCustomerIdCheckBalancePost,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Checks if customer has enough balance using a specific plan for 5 days.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Check Current Customer Balance
   * @param {string} xToken
   * @param {BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost} bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
    xToken: string,
    bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost: BodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).checkCurrentCustomerBalanceCustomersMeCheckBalancePost(
      xToken,
      bodyCheckCurrentCustomerBalanceCustomersMeCheckBalancePost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Customer Billing Info
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customerBillingInfoCustomersCustomerIdBillingDataGet(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).customerBillingInfoCustomersCustomerIdBillingDataGet(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Customer Details
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customerDetailsCustomersCustomerIdGet(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).customerDetailsCustomersCustomerIdGet(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Deactivate Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public deactivateCustomerCustomersCustomerIdDeactivatePost(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).deactivateCustomerCustomersCustomerIdDeactivatePost(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Delete Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public deleteCustomerCustomersCustomerIdDelete(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).deleteCustomerCustomersCustomerIdDelete(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Disables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Disable Billing Suspension Override
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).disableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionDelete(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Enables billing suspension override.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Enable Billing Suspension Override
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).enableBillingSuspensionOverrideCustomersCustomerIdOverrideSuspensionPost(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary List Of Customers
   * @param {string} xToken
   * @param {string} [fullname]
   * @param {string} [email]
   * @param {string} [customerId]
   * @param {number} [start] Filter from timestamp
   * @param {number} [end] Filter to timestamp
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public listOfCustomersCustomersGet(
    xToken: string,
    fullname?: string,
    email?: string,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ) {
    return CustomersApiFp(this.configuration).listOfCustomersCustomersGet(
      xToken,
      fullname,
      email,
      customerId,
      start,
      end,
      page,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Remove unverified email for the customer.       This endpoint can be used by following group(s):  ``admin``.
   * @summary Remove Unverified Email
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).removeUnverifiedEmailCustomersCustomerIdUnverifiedEmailDelete(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Send Reset Password Token
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).sendResetPasswordTokenCustomersCustomerIdResetPasswordPost(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Suspend Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {BodySuspendCustomerCustomersCustomerIdSuspendPost} bodySuspendCustomerCustomersCustomerIdSuspendPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public suspendCustomerCustomersCustomerIdSuspendPost(
    customerId: string,
    xToken: string,
    bodySuspendCustomerCustomersCustomerIdSuspendPost: BodySuspendCustomerCustomersCustomerIdSuspendPost,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).suspendCustomerCustomersCustomerIdSuspendPost(
      customerId,
      xToken,
      bodySuspendCustomerCustomersCustomerIdSuspendPost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Unsuspend Customer
   * @param {string} customerId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public unsuspendCustomerCustomersCustomerIdUnsuspendPost(
    customerId: string,
    xToken: string,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).unsuspendCustomerCustomersCustomerIdUnsuspendPost(
      customerId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Update Customer Profile
   * @param {string} customerId
   * @param {string} xToken
   * @param {CustomerProfileUpdateInputSchema} [customerProfileUpdateInputSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
    customerId: string,
    xToken: string,
    customerProfileUpdateInputSchema?: CustomerProfileUpdateInputSchema,
    options?: any
  ) {
    return CustomersApiFp(
      this.configuration
    ).updateCustomerProfileCustomersCustomerIdUpdateProfilePut(
      customerId,
      xToken,
      customerProfileUpdateInputSchema,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *    Changes instance password, Returns the new password in body.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Instance Password
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeInstancePasswordInstancesInstanceIdChangePassPost(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling changeInstancePasswordInstancesInstanceIdChangePassPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling changeInstancePasswordInstancesInstanceIdChangePassPost."
        );
      }
      const localVarPath = `/instances/{instanceId}/change-pass`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Creates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Create Instance
     * @param {string} xToken
     * @param {InstanceCreateSchema} instanceCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInstanceInstancesPost(
      xToken: string,
      instanceCreateSchema: InstanceCreateSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling createInstanceInstancesPost."
        );
      }
      // verify required parameter 'instanceCreateSchema' is not null or undefined
      if (instanceCreateSchema === null || instanceCreateSchema === undefined) {
        throw new RequiredError(
          "instanceCreateSchema",
          "Required parameter instanceCreateSchema was null or undefined when calling createInstanceInstancesPost."
        );
      }
      const localVarPath = `/instances`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof instanceCreateSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            instanceCreateSchema !== undefined ? instanceCreateSchema : {}
          )
        : instanceCreateSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Delete Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInstanceInstancesInstanceIdDelete(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling deleteInstanceInstancesInstanceIdDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling deleteInstanceInstancesInstanceIdDelete."
        );
      }
      const localVarPath = `/instances/{instanceId}`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Instance Detail
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceDetailInstancesInstanceIdGet(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling getInstanceDetailInstancesInstanceIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getInstanceDetailInstancesInstanceIdGet."
        );
      }
      const localVarPath = `/instances/{instanceId}`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Instances
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstancesInstancesGet(xToken: string, options: any = {}): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listInstancesInstancesGet."
        );
      }
      const localVarPath = `/instances`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Patch Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchInstanceInstancesInstanceIdPatch(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling patchInstanceInstancesInstanceIdPatch."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling patchInstanceInstancesInstanceIdPatch."
        );
      }
      const localVarPath = `/instances/{instanceId}`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof instanceUpdateSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            instanceUpdateSchema !== undefined ? instanceUpdateSchema : {}
          )
        : instanceUpdateSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power Off Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOffInstanceInstancesInstanceIdPoweroffPost(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling powerOffInstanceInstancesInstanceIdPoweroffPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling powerOffInstanceInstancesInstanceIdPoweroffPost."
        );
      }
      const localVarPath = `/instances/{instanceId}/poweroff`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power On Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOnInstanceInstancesInstanceIdPoweronPost(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling powerOnInstanceInstancesInstanceIdPoweronPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling powerOnInstanceInstancesInstanceIdPoweronPost."
        );
      }
      const localVarPath = `/instances/{instanceId}/poweron`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Reset Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInstanceInstancesInstanceIdResetPost(
      instanceId: string,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling resetInstanceInstancesInstanceIdResetPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling resetInstanceInstancesInstanceIdResetPost."
        );
      }
      const localVarPath = `/instances/{instanceId}/reset`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceSuspendInputSchema} instanceSuspendInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendInstanceInstancesInstanceIdSuspendPost(
      instanceId: string,
      xToken: string,
      instanceSuspendInputSchema: InstanceSuspendInputSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling suspendInstanceInstancesInstanceIdSuspendPost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling suspendInstanceInstancesInstanceIdSuspendPost."
        );
      }
      // verify required parameter 'instanceSuspendInputSchema' is not null or undefined
      if (
        instanceSuspendInputSchema === null ||
        instanceSuspendInputSchema === undefined
      ) {
        throw new RequiredError(
          "instanceSuspendInputSchema",
          "Required parameter instanceSuspendInputSchema was null or undefined when calling suspendInstanceInstancesInstanceIdSuspendPost."
        );
      }
      const localVarPath = `/instances/{instanceId}/suspend`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof instanceSuspendInputSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            instanceSuspendInputSchema !== undefined
              ? instanceSuspendInputSchema
              : {}
          )
        : instanceSuspendInputSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Updates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstanceInstancesInstanceIdPut(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'instanceId' is not null or undefined
      if (instanceId === null || instanceId === undefined) {
        throw new RequiredError(
          "instanceId",
          "Required parameter instanceId was null or undefined when calling updateInstanceInstancesInstanceIdPut."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling updateInstanceInstancesInstanceIdPut."
        );
      }
      const localVarPath = `/instances/{instanceId}`.replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(instanceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof instanceUpdateSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            instanceUpdateSchema !== undefined ? instanceUpdateSchema : {}
          )
        : instanceUpdateSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *    Changes instance password, Returns the new password in body.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Instance Password
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeInstancePasswordInstancesInstanceIdChangePassPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).changeInstancePasswordInstancesInstanceIdChangePassPost(
        instanceId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Creates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Create Instance
     * @param {string} xToken
     * @param {InstanceCreateSchema} instanceCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInstanceInstancesPost(
      xToken: string,
      instanceCreateSchema: InstanceCreateSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceDetailSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).createInstanceInstancesPost(xToken, instanceCreateSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Delete Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInstanceInstancesInstanceIdDelete(
      instanceId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).deleteInstanceInstancesInstanceIdDelete(instanceId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Instance Detail
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceDetailInstancesInstanceIdGet(
      instanceId: string,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceDetailSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).getInstanceDetailInstancesInstanceIdGet(instanceId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Instances
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstancesInstancesGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceListSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).listInstancesInstancesGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Patch Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchInstanceInstancesInstanceIdPatch(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceDetailSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).patchInstanceInstancesInstanceIdPatch(
        instanceId,
        xToken,
        instanceUpdateSchema,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power Off Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOffInstanceInstancesInstanceIdPoweroffPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).powerOffInstanceInstancesInstanceIdPoweroffPost(
        instanceId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power On Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOnInstanceInstancesInstanceIdPoweronPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).powerOnInstanceInstancesInstanceIdPoweronPost(
        instanceId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Reset Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInstanceInstancesInstanceIdResetPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).resetInstanceInstancesInstanceIdResetPost(instanceId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceSuspendInputSchema} instanceSuspendInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendInstanceInstancesInstanceIdSuspendPost(
      instanceId: string,
      xToken: string,
      instanceSuspendInputSchema: InstanceSuspendInputSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceSuspendOutputSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).suspendInstanceInstancesInstanceIdSuspendPost(
        instanceId,
        xToken,
        instanceSuspendInputSchema,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Updates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstanceInstancesInstanceIdPut(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InstanceDetailSchema> {
      const localVarAxiosArgs = InstancesApiAxiosParamCreator(
        configuration
      ).updateInstanceInstancesInstanceIdPut(
        instanceId,
        xToken,
        instanceUpdateSchema,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *    Changes instance password, Returns the new password in body.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Change Instance Password
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeInstancePasswordInstancesInstanceIdChangePassPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return InstancesApiFp(
        configuration
      ).changeInstancePasswordInstancesInstanceIdChangePassPost(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    Creates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Create Instance
     * @param {string} xToken
     * @param {InstanceCreateSchema} instanceCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInstanceInstancesPost(
      xToken: string,
      instanceCreateSchema: InstanceCreateSchema,
      options?: any
    ): AxiosPromise<InstanceDetailSchema> {
      return InstancesApiFp(configuration).createInstanceInstancesPost(
        xToken,
        instanceCreateSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Delete Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInstanceInstancesInstanceIdDelete(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return InstancesApiFp(
        configuration
      ).deleteInstanceInstancesInstanceIdDelete(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Instance Detail
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceDetailInstancesInstanceIdGet(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<InstanceDetailSchema> {
      return InstancesApiFp(
        configuration
      ).getInstanceDetailInstancesInstanceIdGet(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Instances
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstancesInstancesGet(
      xToken: string,
      options?: any
    ): AxiosPromise<InstanceListSchema> {
      return InstancesApiFp(configuration).listInstancesInstancesGet(
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Patch Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchInstanceInstancesInstanceIdPatch(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options?: any
    ): AxiosPromise<InstanceDetailSchema> {
      return InstancesApiFp(
        configuration
      ).patchInstanceInstancesInstanceIdPatch(
        instanceId,
        xToken,
        instanceUpdateSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power Off Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOffInstanceInstancesInstanceIdPoweroffPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return InstancesApiFp(
        configuration
      ).powerOffInstanceInstancesInstanceIdPoweroffPost(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Power On Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    powerOnInstanceInstancesInstanceIdPoweronPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return InstancesApiFp(
        configuration
      ).powerOnInstanceInstancesInstanceIdPoweronPost(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Reset Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInstanceInstancesInstanceIdResetPost(
      instanceId: string,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return InstancesApiFp(
        configuration
      ).resetInstanceInstancesInstanceIdResetPost(
        instanceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Suspend Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceSuspendInputSchema} instanceSuspendInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendInstanceInstancesInstanceIdSuspendPost(
      instanceId: string,
      xToken: string,
      instanceSuspendInputSchema: InstanceSuspendInputSchema,
      options?: any
    ): AxiosPromise<InstanceSuspendOutputSchema> {
      return InstancesApiFp(
        configuration
      ).suspendInstanceInstancesInstanceIdSuspendPost(
        instanceId,
        xToken,
        instanceSuspendInputSchema,
        options
      )(axios, basePath);
    },
    /**
     *    Updates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Update Instance
     * @param {string} instanceId
     * @param {string} xToken
     * @param {InstanceUpdateSchema} [instanceUpdateSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstanceInstancesInstanceIdPut(
      instanceId: string,
      xToken: string,
      instanceUpdateSchema?: InstanceUpdateSchema,
      options?: any
    ): AxiosPromise<InstanceDetailSchema> {
      return InstancesApiFp(configuration).updateInstanceInstancesInstanceIdPut(
        instanceId,
        xToken,
        instanceUpdateSchema,
        options
      )(axios, basePath);
    },
  };
};

/**
 * InstancesApi - interface
 * @export
 * @interface InstancesApi
 */
export interface InstancesApiInterface {
  /**
   *    Changes instance password, Returns the new password in body.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Change Instance Password
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  changeInstancePasswordInstancesInstanceIdChangePassPost(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Creates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Create Instance
   * @param {string} xToken
   * @param {InstanceCreateSchema} instanceCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  createInstanceInstancesPost(
    xToken: string,
    instanceCreateSchema: InstanceCreateSchema,
    options?: any
  ): AxiosPromise<InstanceDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Delete Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  deleteInstanceInstancesInstanceIdDelete(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Get Instance Detail
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  getInstanceDetailInstancesInstanceIdGet(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<InstanceDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary List Instances
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  listInstancesInstancesGet(
    xToken: string,
    options?: any
  ): AxiosPromise<InstanceListSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Patch Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceUpdateSchema} [instanceUpdateSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  patchInstanceInstancesInstanceIdPatch(
    instanceId: string,
    xToken: string,
    instanceUpdateSchema?: InstanceUpdateSchema,
    options?: any
  ): AxiosPromise<InstanceDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Power Off Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  powerOffInstanceInstancesInstanceIdPoweroffPost(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Power On Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  powerOnInstanceInstancesInstanceIdPoweronPost(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Reset Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  resetInstanceInstancesInstanceIdResetPost(
    instanceId: string,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Suspend Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceSuspendInputSchema} instanceSuspendInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  suspendInstanceInstancesInstanceIdSuspendPost(
    instanceId: string,
    xToken: string,
    instanceSuspendInputSchema: InstanceSuspendInputSchema,
    options?: any
  ): AxiosPromise<InstanceSuspendOutputSchema>;

  /**
   *    Updates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Update Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceUpdateSchema} [instanceUpdateSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApiInterface
   */
  updateInstanceInstancesInstanceIdPut(
    instanceId: string,
    xToken: string,
    instanceUpdateSchema?: InstanceUpdateSchema,
    options?: any
  ): AxiosPromise<InstanceDetailSchema>;
}

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI implements InstancesApiInterface {
  /**
   *    Changes instance password, Returns the new password in body.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Change Instance Password
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public changeInstancePasswordInstancesInstanceIdChangePassPost(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).changeInstancePasswordInstancesInstanceIdChangePassPost(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Creates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Create Instance
   * @param {string} xToken
   * @param {InstanceCreateSchema} instanceCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public createInstanceInstancesPost(
    xToken: string,
    instanceCreateSchema: InstanceCreateSchema,
    options?: any
  ) {
    return InstancesApiFp(this.configuration).createInstanceInstancesPost(
      xToken,
      instanceCreateSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Delete Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public deleteInstanceInstancesInstanceIdDelete(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).deleteInstanceInstancesInstanceIdDelete(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Get Instance Detail
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public getInstanceDetailInstancesInstanceIdGet(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).getInstanceDetailInstancesInstanceIdGet(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary List Instances
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public listInstancesInstancesGet(xToken: string, options?: any) {
    return InstancesApiFp(this.configuration).listInstancesInstancesGet(
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Patch Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceUpdateSchema} [instanceUpdateSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public patchInstanceInstancesInstanceIdPatch(
    instanceId: string,
    xToken: string,
    instanceUpdateSchema?: InstanceUpdateSchema,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).patchInstanceInstancesInstanceIdPatch(
      instanceId,
      xToken,
      instanceUpdateSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Power Off Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public powerOffInstanceInstancesInstanceIdPoweroffPost(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).powerOffInstanceInstancesInstanceIdPoweroffPost(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Power On Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public powerOnInstanceInstancesInstanceIdPoweronPost(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).powerOnInstanceInstancesInstanceIdPoweronPost(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Reset Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public resetInstanceInstancesInstanceIdResetPost(
    instanceId: string,
    xToken: string,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).resetInstanceInstancesInstanceIdResetPost(
      instanceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Suspend Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceSuspendInputSchema} instanceSuspendInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public suspendInstanceInstancesInstanceIdSuspendPost(
    instanceId: string,
    xToken: string,
    instanceSuspendInputSchema: InstanceSuspendInputSchema,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).suspendInstanceInstancesInstanceIdSuspendPost(
      instanceId,
      xToken,
      instanceSuspendInputSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Updates an instance in Zyrrus.     Admin accounts should pass `customerId` in body.     In case user was a customer his/her id will be extracted from the JWT token.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Update Instance
   * @param {string} instanceId
   * @param {string} xToken
   * @param {InstanceUpdateSchema} [instanceUpdateSchema]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstancesApi
   */
  public updateInstanceInstancesInstanceIdPut(
    instanceId: string,
    xToken: string,
    instanceUpdateSchema?: InstanceUpdateSchema,
    options?: any
  ) {
    return InstancesApiFp(
      this.configuration
    ).updateInstanceInstancesInstanceIdPut(
      instanceId,
      xToken,
      instanceUpdateSchema,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Onetime Invoice
     * @param {string} xToken
     * @param {BodyAddOnetimeInvoiceInvoicesOneTimePost} bodyAddOnetimeInvoiceInvoicesOneTimePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOnetimeInvoiceInvoicesOneTimePost(
      xToken: string,
      bodyAddOnetimeInvoiceInvoicesOneTimePost: BodyAddOnetimeInvoiceInvoicesOneTimePost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling addOnetimeInvoiceInvoicesOneTimePost."
        );
      }
      // verify required parameter 'bodyAddOnetimeInvoiceInvoicesOneTimePost' is not null or undefined
      if (
        bodyAddOnetimeInvoiceInvoicesOneTimePost === null ||
        bodyAddOnetimeInvoiceInvoicesOneTimePost === undefined
      ) {
        throw new RequiredError(
          "bodyAddOnetimeInvoiceInvoicesOneTimePost",
          "Required parameter bodyAddOnetimeInvoiceInvoicesOneTimePost was null or undefined when calling addOnetimeInvoiceInvoicesOneTimePost."
        );
      }
      const localVarPath = `/invoices/one-time`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyAddOnetimeInvoiceInvoicesOneTimePost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyAddOnetimeInvoiceInvoicesOneTimePost !== undefined
              ? bodyAddOnetimeInvoiceInvoicesOneTimePost
              : {}
          )
        : bodyAddOnetimeInvoiceInvoicesOneTimePost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Invoice Detail
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceDetailInvoicesInvoiceIdGet(
      invoiceId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'invoiceId' is not null or undefined
      if (invoiceId === null || invoiceId === undefined) {
        throw new RequiredError(
          "invoiceId",
          "Required parameter invoiceId was null or undefined when calling getInvoiceDetailInvoicesInvoiceIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getInvoiceDetailInvoicesInvoiceIdGet."
        );
      }
      const localVarPath = `/invoices/{invoiceId}`.replace(
        `{${"invoiceId"}}`,
        encodeURIComponent(String(invoiceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Invoices
     * @param {string} xToken
     * @param {string} [email]
     * @param {string} [fullname]
     * @param {InvoiceStatusEnum} [status]
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoicesInvoicesGet(
      xToken: string,
      email?: string,
      fullname?: string,
      status?: InvoiceStatusEnum,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listInvoicesInvoicesGet."
        );
      }
      const localVarPath = `/invoices`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      if (fullname !== undefined) {
        localVarQueryParameter["fullname"] = fullname;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = end;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Share Invoice
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {BodyShareInvoiceInvoicesInvoiceIdSharePost} [bodyShareInvoiceInvoicesInvoiceIdSharePost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareInvoiceInvoicesInvoiceIdSharePost(
      invoiceId: number,
      xToken: string,
      bodyShareInvoiceInvoicesInvoiceIdSharePost?: BodyShareInvoiceInvoicesInvoiceIdSharePost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'invoiceId' is not null or undefined
      if (invoiceId === null || invoiceId === undefined) {
        throw new RequiredError(
          "invoiceId",
          "Required parameter invoiceId was null or undefined when calling shareInvoiceInvoicesInvoiceIdSharePost."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling shareInvoiceInvoicesInvoiceIdSharePost."
        );
      }
      const localVarPath = `/invoices/{invoiceId}/share`.replace(
        `{${"invoiceId"}}`,
        encodeURIComponent(String(invoiceId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyShareInvoiceInvoicesInvoiceIdSharePost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyShareInvoiceInvoicesInvoiceIdSharePost !== undefined
              ? bodyShareInvoiceInvoicesInvoiceIdSharePost
              : {}
          )
        : bodyShareInvoiceInvoicesInvoiceIdSharePost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Onetime Invoice
     * @param {string} xToken
     * @param {BodyAddOnetimeInvoiceInvoicesOneTimePost} bodyAddOnetimeInvoiceInvoicesOneTimePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOnetimeInvoiceInvoicesOneTimePost(
      xToken: string,
      bodyAddOnetimeInvoiceInvoicesOneTimePost: BodyAddOnetimeInvoiceInvoicesOneTimePost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InvoicesApiAxiosParamCreator(
        configuration
      ).addOnetimeInvoiceInvoicesOneTimePost(
        xToken,
        bodyAddOnetimeInvoiceInvoicesOneTimePost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Invoice Detail
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceDetailInvoicesInvoiceIdGet(
      invoiceId: number,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InvoiceDetailSchema> {
      const localVarAxiosArgs = InvoicesApiAxiosParamCreator(
        configuration
      ).getInvoiceDetailInvoicesInvoiceIdGet(invoiceId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Invoices
     * @param {string} xToken
     * @param {string} [email]
     * @param {string} [fullname]
     * @param {InvoiceStatusEnum} [status]
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoicesInvoicesGet(
      xToken: string,
      email?: string,
      fullname?: string,
      status?: InvoiceStatusEnum,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InvoiceListResponseSchema> {
      const localVarAxiosArgs = InvoicesApiAxiosParamCreator(
        configuration
      ).listInvoicesInvoicesGet(
        xToken,
        email,
        fullname,
        status,
        customerId,
        start,
        end,
        page,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Share Invoice
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {BodyShareInvoiceInvoicesInvoiceIdSharePost} [bodyShareInvoiceInvoicesInvoiceIdSharePost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareInvoiceInvoicesInvoiceIdSharePost(
      invoiceId: number,
      xToken: string,
      bodyShareInvoiceInvoicesInvoiceIdSharePost?: BodyShareInvoiceInvoicesInvoiceIdSharePost,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = InvoicesApiAxiosParamCreator(
        configuration
      ).shareInvoiceInvoicesInvoiceIdSharePost(
        invoiceId,
        xToken,
        bodyShareInvoiceInvoicesInvoiceIdSharePost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``admin``.
     * @summary Add Onetime Invoice
     * @param {string} xToken
     * @param {BodyAddOnetimeInvoiceInvoicesOneTimePost} bodyAddOnetimeInvoiceInvoicesOneTimePost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOnetimeInvoiceInvoicesOneTimePost(
      xToken: string,
      bodyAddOnetimeInvoiceInvoicesOneTimePost: BodyAddOnetimeInvoiceInvoicesOneTimePost,
      options?: any
    ): AxiosPromise<object> {
      return InvoicesApiFp(configuration).addOnetimeInvoiceInvoicesOneTimePost(
        xToken,
        bodyAddOnetimeInvoiceInvoicesOneTimePost,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Invoice Detail
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoiceDetailInvoicesInvoiceIdGet(
      invoiceId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<InvoiceDetailSchema> {
      return InvoicesApiFp(configuration).getInvoiceDetailInvoicesInvoiceIdGet(
        invoiceId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Invoices
     * @param {string} xToken
     * @param {string} [email]
     * @param {string} [fullname]
     * @param {InvoiceStatusEnum} [status]
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoicesInvoicesGet(
      xToken: string,
      email?: string,
      fullname?: string,
      status?: InvoiceStatusEnum,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): AxiosPromise<InvoiceListResponseSchema> {
      return InvoicesApiFp(configuration).listInvoicesInvoicesGet(
        xToken,
        email,
        fullname,
        status,
        customerId,
        start,
        end,
        page,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Share Invoice
     * @param {number} invoiceId
     * @param {string} xToken
     * @param {BodyShareInvoiceInvoicesInvoiceIdSharePost} [bodyShareInvoiceInvoicesInvoiceIdSharePost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareInvoiceInvoicesInvoiceIdSharePost(
      invoiceId: number,
      xToken: string,
      bodyShareInvoiceInvoicesInvoiceIdSharePost?: BodyShareInvoiceInvoicesInvoiceIdSharePost,
      options?: any
    ): AxiosPromise<object> {
      return InvoicesApiFp(
        configuration
      ).shareInvoiceInvoicesInvoiceIdSharePost(
        invoiceId,
        xToken,
        bodyShareInvoiceInvoicesInvoiceIdSharePost,
        options
      )(axios, basePath);
    },
  };
};

/**
 * InvoicesApi - interface
 * @export
 * @interface InvoicesApi
 */
export interface InvoicesApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Onetime Invoice
   * @param {string} xToken
   * @param {BodyAddOnetimeInvoiceInvoicesOneTimePost} bodyAddOnetimeInvoiceInvoicesOneTimePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApiInterface
   */
  addOnetimeInvoiceInvoicesOneTimePost(
    xToken: string,
    bodyAddOnetimeInvoiceInvoicesOneTimePost: BodyAddOnetimeInvoiceInvoicesOneTimePost,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Invoice Detail
   * @param {number} invoiceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApiInterface
   */
  getInvoiceDetailInvoicesInvoiceIdGet(
    invoiceId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<InvoiceDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Invoices
   * @param {string} xToken
   * @param {string} [email]
   * @param {string} [fullname]
   * @param {InvoiceStatusEnum} [status]
   * @param {string} [customerId]
   * @param {number} [start]
   * @param {number} [end]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApiInterface
   */
  listInvoicesInvoicesGet(
    xToken: string,
    email?: string,
    fullname?: string,
    status?: InvoiceStatusEnum,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ): AxiosPromise<InvoiceListResponseSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Share Invoice
   * @param {number} invoiceId
   * @param {string} xToken
   * @param {BodyShareInvoiceInvoicesInvoiceIdSharePost} [bodyShareInvoiceInvoicesInvoiceIdSharePost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApiInterface
   */
  shareInvoiceInvoicesInvoiceIdSharePost(
    invoiceId: number,
    xToken: string,
    bodyShareInvoiceInvoicesInvoiceIdSharePost?: BodyShareInvoiceInvoicesInvoiceIdSharePost,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI implements InvoicesApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``admin``.
   * @summary Add Onetime Invoice
   * @param {string} xToken
   * @param {BodyAddOnetimeInvoiceInvoicesOneTimePost} bodyAddOnetimeInvoiceInvoicesOneTimePost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public addOnetimeInvoiceInvoicesOneTimePost(
    xToken: string,
    bodyAddOnetimeInvoiceInvoicesOneTimePost: BodyAddOnetimeInvoiceInvoicesOneTimePost,
    options?: any
  ) {
    return InvoicesApiFp(
      this.configuration
    ).addOnetimeInvoiceInvoicesOneTimePost(
      xToken,
      bodyAddOnetimeInvoiceInvoicesOneTimePost,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Invoice Detail
   * @param {number} invoiceId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public getInvoiceDetailInvoicesInvoiceIdGet(
    invoiceId: number,
    xToken: string,
    options?: any
  ) {
    return InvoicesApiFp(
      this.configuration
    ).getInvoiceDetailInvoicesInvoiceIdGet(
      invoiceId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Invoices
   * @param {string} xToken
   * @param {string} [email]
   * @param {string} [fullname]
   * @param {InvoiceStatusEnum} [status]
   * @param {string} [customerId]
   * @param {number} [start]
   * @param {number} [end]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public listInvoicesInvoicesGet(
    xToken: string,
    email?: string,
    fullname?: string,
    status?: InvoiceStatusEnum,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration).listInvoicesInvoicesGet(
      xToken,
      email,
      fullname,
      status,
      customerId,
      start,
      end,
      page,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Share Invoice
   * @param {number} invoiceId
   * @param {string} xToken
   * @param {BodyShareInvoiceInvoicesInvoiceIdSharePost} [bodyShareInvoiceInvoicesInvoiceIdSharePost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public shareInvoiceInvoicesInvoiceIdSharePost(
    invoiceId: number,
    xToken: string,
    bodyShareInvoiceInvoicesInvoiceIdSharePost?: BodyShareInvoiceInvoicesInvoiceIdSharePost,
    options?: any
  ) {
    return InvoicesApiFp(
      this.configuration
    ).shareInvoiceInvoicesInvoiceIdSharePost(
      invoiceId,
      xToken,
      bodyShareInvoiceInvoicesInvoiceIdSharePost,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * OperatingSystemsApi - axios parameter creator
 * @export
 */
export const OperatingSystemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *    List of all operating systems.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Os
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOsOsGet(xToken: string, options: any = {}): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listOsOsGet."
        );
      }
      const localVarPath = `/os`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OperatingSystemsApi - functional programming interface
 * @export
 */
export const OperatingSystemsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *    List of all operating systems.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Os
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOsOsGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<OsListSchema> {
      const localVarAxiosArgs = OperatingSystemsApiAxiosParamCreator(
        configuration
      ).listOsOsGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * OperatingSystemsApi - factory interface
 * @export
 */
export const OperatingSystemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *    List of all operating systems.       This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary List Os
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOsOsGet(xToken: string, options?: any): AxiosPromise<OsListSchema> {
      return OperatingSystemsApiFp(configuration).listOsOsGet(xToken, options)(
        axios,
        basePath
      );
    },
  };
};

/**
 * OperatingSystemsApi - interface
 * @export
 * @interface OperatingSystemsApi
 */
export interface OperatingSystemsApiInterface {
  /**
   *    List of all operating systems.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary List Os
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperatingSystemsApiInterface
   */
  listOsOsGet(xToken: string, options?: any): AxiosPromise<OsListSchema>;
}

/**
 * OperatingSystemsApi - object-oriented interface
 * @export
 * @class OperatingSystemsApi
 * @extends {BaseAPI}
 */
export class OperatingSystemsApi
  extends BaseAPI
  implements OperatingSystemsApiInterface
{
  /**
   *    List of all operating systems.       This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary List Os
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperatingSystemsApi
   */
  public listOsOsGet(xToken: string, options?: any) {
    return OperatingSystemsApiFp(this.configuration).listOsOsGet(
      xToken,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Add Payment
     * @param {string} xToken
     * @param {CreatePaymentInputSchema} createPaymentInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPaymentPaymentsPost(
      xToken: string,
      createPaymentInputSchema: CreatePaymentInputSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling addPaymentPaymentsPost."
        );
      }
      // verify required parameter 'createPaymentInputSchema' is not null or undefined
      if (
        createPaymentInputSchema === null ||
        createPaymentInputSchema === undefined
      ) {
        throw new RequiredError(
          "createPaymentInputSchema",
          "Required parameter createPaymentInputSchema was null or undefined when calling addPaymentPaymentsPost."
        );
      }
      const localVarPath = `/payments`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof createPaymentInputSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createPaymentInputSchema !== undefined
              ? createPaymentInputSchema
              : {}
          )
        : createPaymentInputSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Payment Detail
     * @param {number} paymentId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentDetailPaymentsPaymentIdGet(
      paymentId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'paymentId' is not null or undefined
      if (paymentId === null || paymentId === undefined) {
        throw new RequiredError(
          "paymentId",
          "Required parameter paymentId was null or undefined when calling getPaymentDetailPaymentsPaymentIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getPaymentDetailPaymentsPaymentIdGet."
        );
      }
      const localVarPath = `/payments/{paymentId}`.replace(
        `{${"paymentId"}}`,
        encodeURIComponent(String(paymentId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Of Payments
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {string} [fullname]
     * @param {number} [start]
     * @param {number} [end]
     * @param {string} [email]
     * @param {PaymentStatusEnum} [status]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfPaymentsPaymentsGet(
      xToken: string,
      customerId?: string,
      fullname?: string,
      start?: number,
      end?: number,
      email?: string,
      status?: PaymentStatusEnum,
      page?: number,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listOfPaymentsPaymentsGet."
        );
      }
      const localVarPath = `/payments`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (fullname !== undefined) {
        localVarQueryParameter["fullname"] = fullname;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = end;
      }

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Use Coupon
     * @param {string} xToken
     * @param {BodyUseCouponPaymentsCouponPost} bodyUseCouponPaymentsCouponPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    useCouponPaymentsCouponPost(
      xToken: string,
      bodyUseCouponPaymentsCouponPost: BodyUseCouponPaymentsCouponPost,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling useCouponPaymentsCouponPost."
        );
      }
      // verify required parameter 'bodyUseCouponPaymentsCouponPost' is not null or undefined
      if (
        bodyUseCouponPaymentsCouponPost === null ||
        bodyUseCouponPaymentsCouponPost === undefined
      ) {
        throw new RequiredError(
          "bodyUseCouponPaymentsCouponPost",
          "Required parameter bodyUseCouponPaymentsCouponPost was null or undefined when calling useCouponPaymentsCouponPost."
        );
      }
      const localVarPath = `/payments/coupon`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyUseCouponPaymentsCouponPost !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyUseCouponPaymentsCouponPost !== undefined
              ? bodyUseCouponPaymentsCouponPost
              : {}
          )
        : bodyUseCouponPaymentsCouponPost || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Add Payment
     * @param {string} xToken
     * @param {CreatePaymentInputSchema} createPaymentInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPaymentPaymentsPost(
      xToken: string,
      createPaymentInputSchema: CreatePaymentInputSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CreatePaymentResponseSchema> {
      const localVarAxiosArgs = PaymentsApiAxiosParamCreator(
        configuration
      ).addPaymentPaymentsPost(xToken, createPaymentInputSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Payment Detail
     * @param {number} paymentId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentDetailPaymentsPaymentIdGet(
      paymentId: number,
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PaymentDetailSchema> {
      const localVarAxiosArgs = PaymentsApiAxiosParamCreator(
        configuration
      ).getPaymentDetailPaymentsPaymentIdGet(paymentId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Of Payments
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {string} [fullname]
     * @param {number} [start]
     * @param {number} [end]
     * @param {string} [email]
     * @param {PaymentStatusEnum} [status]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfPaymentsPaymentsGet(
      xToken: string,
      customerId?: string,
      fullname?: string,
      start?: number,
      end?: number,
      email?: string,
      status?: PaymentStatusEnum,
      page?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PaymentListResponseSchema> {
      const localVarAxiosArgs = PaymentsApiAxiosParamCreator(
        configuration
      ).listOfPaymentsPaymentsGet(
        xToken,
        customerId,
        fullname,
        start,
        end,
        email,
        status,
        page,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Use Coupon
     * @param {string} xToken
     * @param {BodyUseCouponPaymentsCouponPost} bodyUseCouponPaymentsCouponPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    useCouponPaymentsCouponPost(
      xToken: string,
      bodyUseCouponPaymentsCouponPost: BodyUseCouponPaymentsCouponPost,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<UseCouponAsPaymentResponseSchema> {
      const localVarAxiosArgs = PaymentsApiAxiosParamCreator(
        configuration
      ).useCouponPaymentsCouponPost(
        xToken,
        bodyUseCouponPaymentsCouponPost,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Add Payment
     * @param {string} xToken
     * @param {CreatePaymentInputSchema} createPaymentInputSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPaymentPaymentsPost(
      xToken: string,
      createPaymentInputSchema: CreatePaymentInputSchema,
      options?: any
    ): AxiosPromise<CreatePaymentResponseSchema> {
      return PaymentsApiFp(configuration).addPaymentPaymentsPost(
        xToken,
        createPaymentInputSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Payment Detail
     * @param {number} paymentId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentDetailPaymentsPaymentIdGet(
      paymentId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<PaymentDetailSchema> {
      return PaymentsApiFp(configuration).getPaymentDetailPaymentsPaymentIdGet(
        paymentId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Of Payments
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {string} [fullname]
     * @param {number} [start]
     * @param {number} [end]
     * @param {string} [email]
     * @param {PaymentStatusEnum} [status]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOfPaymentsPaymentsGet(
      xToken: string,
      customerId?: string,
      fullname?: string,
      start?: number,
      end?: number,
      email?: string,
      status?: PaymentStatusEnum,
      page?: number,
      options?: any
    ): AxiosPromise<PaymentListResponseSchema> {
      return PaymentsApiFp(configuration).listOfPaymentsPaymentsGet(
        xToken,
        customerId,
        fullname,
        start,
        end,
        email,
        status,
        page,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Use Coupon
     * @param {string} xToken
     * @param {BodyUseCouponPaymentsCouponPost} bodyUseCouponPaymentsCouponPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    useCouponPaymentsCouponPost(
      xToken: string,
      bodyUseCouponPaymentsCouponPost: BodyUseCouponPaymentsCouponPost,
      options?: any
    ): AxiosPromise<UseCouponAsPaymentResponseSchema> {
      return PaymentsApiFp(configuration).useCouponPaymentsCouponPost(
        xToken,
        bodyUseCouponPaymentsCouponPost,
        options
      )(axios, basePath);
    },
  };
};

/**
 * PaymentsApi - interface
 * @export
 * @interface PaymentsApi
 */
export interface PaymentsApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Add Payment
   * @param {string} xToken
   * @param {CreatePaymentInputSchema} createPaymentInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApiInterface
   */
  addPaymentPaymentsPost(
    xToken: string,
    createPaymentInputSchema: CreatePaymentInputSchema,
    options?: any
  ): AxiosPromise<CreatePaymentResponseSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Payment Detail
   * @param {number} paymentId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApiInterface
   */
  getPaymentDetailPaymentsPaymentIdGet(
    paymentId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<PaymentDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Of Payments
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {string} [fullname]
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [email]
   * @param {PaymentStatusEnum} [status]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApiInterface
   */
  listOfPaymentsPaymentsGet(
    xToken: string,
    customerId?: string,
    fullname?: string,
    start?: number,
    end?: number,
    email?: string,
    status?: PaymentStatusEnum,
    page?: number,
    options?: any
  ): AxiosPromise<PaymentListResponseSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Use Coupon
   * @param {string} xToken
   * @param {BodyUseCouponPaymentsCouponPost} bodyUseCouponPaymentsCouponPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApiInterface
   */
  useCouponPaymentsCouponPost(
    xToken: string,
    bodyUseCouponPaymentsCouponPost: BodyUseCouponPaymentsCouponPost,
    options?: any
  ): AxiosPromise<UseCouponAsPaymentResponseSchema>;
}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI implements PaymentsApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Add Payment
   * @param {string} xToken
   * @param {CreatePaymentInputSchema} createPaymentInputSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public addPaymentPaymentsPost(
    xToken: string,
    createPaymentInputSchema: CreatePaymentInputSchema,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration).addPaymentPaymentsPost(
      xToken,
      createPaymentInputSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Payment Detail
   * @param {number} paymentId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public getPaymentDetailPaymentsPaymentIdGet(
    paymentId: number,
    xToken: string,
    options?: any
  ) {
    return PaymentsApiFp(
      this.configuration
    ).getPaymentDetailPaymentsPaymentIdGet(
      paymentId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Of Payments
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {string} [fullname]
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [email]
   * @param {PaymentStatusEnum} [status]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public listOfPaymentsPaymentsGet(
    xToken: string,
    customerId?: string,
    fullname?: string,
    start?: number,
    end?: number,
    email?: string,
    status?: PaymentStatusEnum,
    page?: number,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration).listOfPaymentsPaymentsGet(
      xToken,
      customerId,
      fullname,
      start,
      end,
      email,
      status,
      page,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Use Coupon
   * @param {string} xToken
   * @param {BodyUseCouponPaymentsCouponPost} bodyUseCouponPaymentsCouponPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public useCouponPaymentsCouponPost(
    xToken: string,
    bodyUseCouponPaymentsCouponPost: BodyUseCouponPaymentsCouponPost,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration).useCouponPaymentsCouponPost(
      xToken,
      bodyUseCouponPaymentsCouponPost,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * PlansApi - axios parameter creator
 * @export
 */
export const PlansApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get Plan
     * @param {string} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlanPlansPlanIdGet(planId: string, options: any = {}): RequestArgs {
      // verify required parameter 'planId' is not null or undefined
      if (planId === null || planId === undefined) {
        throw new RequiredError(
          "planId",
          "Required parameter planId was null or undefined when calling getPlanPlansPlanIdGet."
        );
      }
      const localVarPath = `/plans/{plan_id}`.replace(
        `{${"plan_id"}}`,
        encodeURIComponent(String(planId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPlansPlansGet(options: any = {}): RequestArgs {
      const localVarPath = `/plans`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get Plan
     * @param {string} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlanPlansPlanIdGet(
      planId: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanSchema> {
      const localVarAxiosArgs = PlansApiAxiosParamCreator(
        configuration
      ).getPlanPlansPlanIdGet(planId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary List Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPlansPlansGet(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PlanListSchema> {
      const localVarAxiosArgs =
        PlansApiAxiosParamCreator(configuration).listPlansPlansGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Get Plan
     * @param {string} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlanPlansPlanIdGet(
      planId: string,
      options?: any
    ): AxiosPromise<PlanSchema> {
      return PlansApiFp(configuration).getPlanPlansPlanIdGet(planId, options)(
        axios,
        basePath
      );
    },
    /**
     *
     * @summary List Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPlansPlansGet(options?: any): AxiosPromise<PlanListSchema> {
      return PlansApiFp(configuration).listPlansPlansGet(options)(
        axios,
        basePath
      );
    },
  };
};

/**
 * PlansApi - interface
 * @export
 * @interface PlansApi
 */
export interface PlansApiInterface {
  /**
   *
   * @summary Get Plan
   * @param {string} planId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApiInterface
   */
  getPlanPlansPlanIdGet(
    planId: string,
    options?: any
  ): AxiosPromise<PlanSchema>;

  /**
   *
   * @summary List Plans
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApiInterface
   */
  listPlansPlansGet(options?: any): AxiosPromise<PlanListSchema>;
}

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI implements PlansApiInterface {
  /**
   *
   * @summary Get Plan
   * @param {string} planId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApi
   */
  public getPlanPlansPlanIdGet(planId: string, options?: any) {
    return PlansApiFp(this.configuration).getPlanPlansPlanIdGet(
      planId,
      options
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary List Plans
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApi
   */
  public listPlansPlansGet(options?: any) {
    return PlansApiFp(this.configuration).listPlansPlansGet(options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * PrivateAuthApi - axios parameter creator
 * @export
 */
export const PrivateAuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Get Full Session
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFullSessionTicketingAuthGetSessionGet(
      sessionString: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'sessionString' is not null or undefined
      if (sessionString === null || sessionString === undefined) {
        throw new RequiredError(
          "sessionString",
          "Required parameter sessionString was null or undefined when calling getFullSessionTicketingAuthGetSessionGet."
        );
      }
      const localVarPath = `/ticketing-auth/get-session`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sessionString !== undefined) {
        localVarQueryParameter["session_string"] = sessionString;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Login Into Ticketing
     * @param {string} username
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginIntoTicketingTicketingAuthLoginGet(
      username: string,
      password: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          "username",
          "Required parameter username was null or undefined when calling loginIntoTicketingTicketingAuthLoginGet."
        );
      }
      // verify required parameter 'password' is not null or undefined
      if (password === null || password === undefined) {
        throw new RequiredError(
          "password",
          "Required parameter password was null or undefined when calling loginIntoTicketingTicketingAuthLoginGet."
        );
      }
      const localVarPath = `/ticketing-auth/login`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (password !== undefined) {
        localVarQueryParameter["password"] = password;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Logout From Ticketing
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutFromTicketingTicketingAuthLogoutGet(
      sessionString: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'sessionString' is not null or undefined
      if (sessionString === null || sessionString === undefined) {
        throw new RequiredError(
          "sessionString",
          "Required parameter sessionString was null or undefined when calling logoutFromTicketingTicketingAuthLogoutGet."
        );
      }
      const localVarPath = `/ticketing-auth/logout`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sessionString !== undefined) {
        localVarQueryParameter["session_string"] = sessionString;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PrivateAuthApi - functional programming interface
 * @export
 */
export const PrivateAuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Get Full Session
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFullSessionTicketingAuthGetSessionGet(
      sessionString: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = PrivateAuthApiAxiosParamCreator(
        configuration
      ).getFullSessionTicketingAuthGetSessionGet(sessionString, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Login Into Ticketing
     * @param {string} username
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginIntoTicketingTicketingAuthLoginGet(
      username: string,
      password: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<InitSessionOutputSchema> {
      const localVarAxiosArgs = PrivateAuthApiAxiosParamCreator(
        configuration
      ).loginIntoTicketingTicketingAuthLoginGet(username, password, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Logout From Ticketing
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutFromTicketingTicketingAuthLogoutGet(
      sessionString: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = PrivateAuthApiAxiosParamCreator(
        configuration
      ).logoutFromTicketingTicketingAuthLogoutGet(sessionString, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PrivateAuthApi - factory interface
 * @export
 */
export const PrivateAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Get Full Session
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFullSessionTicketingAuthGetSessionGet(
      sessionString: string,
      options?: any
    ): AxiosPromise<object> {
      return PrivateAuthApiFp(
        configuration
      ).getFullSessionTicketingAuthGetSessionGet(sessionString, options)(
        axios,
        basePath
      );
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Login Into Ticketing
     * @param {string} username
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginIntoTicketingTicketingAuthLoginGet(
      username: string,
      password: string,
      options?: any
    ): AxiosPromise<InitSessionOutputSchema> {
      return PrivateAuthApiFp(
        configuration
      ).loginIntoTicketingTicketingAuthLoginGet(
        username,
        password,
        options
      )(axios, basePath);
    },
    /**
     * **This endpoint is not meant to be used by frontend and it will be removed later.**
     * @summary Logout From Ticketing
     * @param {string} sessionString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutFromTicketingTicketingAuthLogoutGet(
      sessionString: string,
      options?: any
    ): AxiosPromise<object> {
      return PrivateAuthApiFp(
        configuration
      ).logoutFromTicketingTicketingAuthLogoutGet(sessionString, options)(
        axios,
        basePath
      );
    },
  };
};

/**
 * PrivateAuthApi - interface
 * @export
 * @interface PrivateAuthApi
 */
export interface PrivateAuthApiInterface {
  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Get Full Session
   * @param {string} sessionString
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApiInterface
   */
  getFullSessionTicketingAuthGetSessionGet(
    sessionString: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Login Into Ticketing
   * @param {string} username
   * @param {string} password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApiInterface
   */
  loginIntoTicketingTicketingAuthLoginGet(
    username: string,
    password: string,
    options?: any
  ): AxiosPromise<InitSessionOutputSchema>;

  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Logout From Ticketing
   * @param {string} sessionString
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApiInterface
   */
  logoutFromTicketingTicketingAuthLogoutGet(
    sessionString: string,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * PrivateAuthApi - object-oriented interface
 * @export
 * @class PrivateAuthApi
 * @extends {BaseAPI}
 */
export class PrivateAuthApi extends BaseAPI implements PrivateAuthApiInterface {
  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Get Full Session
   * @param {string} sessionString
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApi
   */
  public getFullSessionTicketingAuthGetSessionGet(
    sessionString: string,
    options?: any
  ) {
    return PrivateAuthApiFp(
      this.configuration
    ).getFullSessionTicketingAuthGetSessionGet(sessionString, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Login Into Ticketing
   * @param {string} username
   * @param {string} password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApi
   */
  public loginIntoTicketingTicketingAuthLoginGet(
    username: string,
    password: string,
    options?: any
  ) {
    return PrivateAuthApiFp(
      this.configuration
    ).loginIntoTicketingTicketingAuthLoginGet(
      username,
      password,
      options
    )(this.axios, this.basePath);
  }

  /**
   * **This endpoint is not meant to be used by frontend and it will be removed later.**
   * @summary Logout From Ticketing
   * @param {string} sessionString
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrivateAuthApi
   */
  public logoutFromTicketingTicketingAuthLogoutGet(
    sessionString: string,
    options?: any
  ) {
    return PrivateAuthApiFp(
      this.configuration
    ).logoutFromTicketingTicketingAuthLogoutGet(sessionString, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Current User Billing Data
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    currentUserBillingDataProfileBillingInfoGet(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling currentUserBillingDataProfileBillingInfoGet."
        );
      }
      const localVarPath = `/profile/billing-info`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoProfileUserInfoGet(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getCurrentUserInfoProfileUserInfoGet."
        );
      }
      const localVarPath = `/profile/user-info`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Current User Billing Data
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    currentUserBillingDataProfileBillingInfoGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CustomerBillingDetailSchema> {
      const localVarAxiosArgs = ProfileApiAxiosParamCreator(
        configuration
      ).currentUserBillingDataProfileBillingInfoGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoProfileUserInfoGet(
      xToken: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CurrentUserInfoSchema> {
      const localVarAxiosArgs = ProfileApiAxiosParamCreator(
        configuration
      ).getCurrentUserInfoProfileUserInfoGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Current User Billing Data
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    currentUserBillingDataProfileBillingInfoGet(
      xToken: string,
      options?: any
    ): AxiosPromise<CustomerBillingDetailSchema> {
      return ProfileApiFp(
        configuration
      ).currentUserBillingDataProfileBillingInfoGet(xToken, options)(
        axios,
        basePath
      );
    },
    /**
     * This endpoint can be used by following group(s):  ``admin``,``customer``.
     * @summary Get Current User Info
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInfoProfileUserInfoGet(
      xToken: string,
      options?: any
    ): AxiosPromise<CurrentUserInfoSchema> {
      return ProfileApiFp(configuration).getCurrentUserInfoProfileUserInfoGet(
        xToken,
        options
      )(axios, basePath);
    },
  };
};

/**
 * ProfileApi - interface
 * @export
 * @interface ProfileApi
 */
export interface ProfileApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Current User Billing Data
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApiInterface
   */
  currentUserBillingDataProfileBillingInfoGet(
    xToken: string,
    options?: any
  ): AxiosPromise<CustomerBillingDetailSchema>;

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Get Current User Info
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApiInterface
   */
  getCurrentUserInfoProfileUserInfoGet(
    xToken: string,
    options?: any
  ): AxiosPromise<CurrentUserInfoSchema>;
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI implements ProfileApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Current User Billing Data
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public currentUserBillingDataProfileBillingInfoGet(
    xToken: string,
    options?: any
  ) {
    return ProfileApiFp(
      this.configuration
    ).currentUserBillingDataProfileBillingInfoGet(xToken, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * This endpoint can be used by following group(s):  ``admin``,``customer``.
   * @summary Get Current User Info
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public getCurrentUserInfoProfileUserInfoGet(xToken: string, options?: any) {
    return ProfileApiFp(
      this.configuration
    ).getCurrentUserInfoProfileUserInfoGet(xToken, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * SSHKeysApi - axios parameter creator
 * @export
 */
export const SSHKeysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new SSH key for current or specified user.     - Admin group should provide desired customer_id to create SSH key for the specified user.    - For customer group, user id will be picked from the entered JWT token. And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Create New Ssh Key
     * @param {string} xToken
     * @param {SSHKeyWriteSchema} sSHKeyWriteSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewSshKeySshKeysPost(
      xToken: string,
      sSHKeyWriteSchema: SSHKeyWriteSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling createNewSshKeySshKeysPost."
        );
      }
      // verify required parameter 'sSHKeyWriteSchema' is not null or undefined
      if (sSHKeyWriteSchema === null || sSHKeyWriteSchema === undefined) {
        throw new RequiredError(
          "sSHKeyWriteSchema",
          "Required parameter sSHKeyWriteSchema was null or undefined when calling createNewSshKeySshKeysPost."
        );
      }
      const localVarPath = `/ssh-keys`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof sSHKeyWriteSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            sSHKeyWriteSchema !== undefined ? sSHKeyWriteSchema : {}
          )
        : sSHKeyWriteSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes SSH key.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token. And the entered one will be ignored.   This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Delete Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSshKeySshKeysIdDelete(
      id: number,
      xToken: string,
      customerId?: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteSshKeySshKeysIdDelete."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling deleteSshKeySshKeysIdDelete."
        );
      }
      const localVarPath = `/ssh-keys/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a specific ssh key owned specified or current user.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSshKeySshKeysIdGet(
      id: number,
      xToken: string,
      customerId?: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getSshKeySshKeysIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getSshKeySshKeysIdGet."
        );
      }
      const localVarPath = `/ssh-keys/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List of ssh keys for a user.     - Admins group should provide customer id to get SSH keys for that customer.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Ssh Keys
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSshKeysSshKeysGet(
      xToken: string,
      customerId?: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listSshKeysSshKeysGet."
        );
      }
      const localVarPath = `/ssh-keys`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SSHKeysApi - functional programming interface
 * @export
 */
export const SSHKeysApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new SSH key for current or specified user.     - Admin group should provide desired customer_id to create SSH key for the specified user.    - For customer group, user id will be picked from the entered JWT token. And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Create New Ssh Key
     * @param {string} xToken
     * @param {SSHKeyWriteSchema} sSHKeyWriteSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewSshKeySshKeysPost(
      xToken: string,
      sSHKeyWriteSchema: SSHKeyWriteSchema,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SSHKeysApiAxiosParamCreator(
        configuration
      ).createNewSshKeySshKeysPost(xToken, sSHKeyWriteSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes SSH key.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token. And the entered one will be ignored.   This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Delete Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSshKeySshKeysIdDelete(
      id: number,
      xToken: string,
      customerId?: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SSHKeysApiAxiosParamCreator(
        configuration
      ).deleteSshKeySshKeysIdDelete(id, xToken, customerId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve a specific ssh key owned specified or current user.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSshKeySshKeysIdGet(
      id: number,
      xToken: string,
      customerId?: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<SSHKeyReadSchema> {
      const localVarAxiosArgs = SSHKeysApiAxiosParamCreator(
        configuration
      ).getSshKeySshKeysIdGet(id, xToken, customerId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * List of ssh keys for a user.     - Admins group should provide customer id to get SSH keys for that customer.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Ssh Keys
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSshKeysSshKeysGet(
      xToken: string,
      customerId?: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<Array<SSHKeyReadSchema>> {
      const localVarAxiosArgs = SSHKeysApiAxiosParamCreator(
        configuration
      ).listSshKeysSshKeysGet(xToken, customerId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SSHKeysApi - factory interface
 * @export
 */
export const SSHKeysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Creates a new SSH key for current or specified user.     - Admin group should provide desired customer_id to create SSH key for the specified user.    - For customer group, user id will be picked from the entered JWT token. And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Create New Ssh Key
     * @param {string} xToken
     * @param {SSHKeyWriteSchema} sSHKeyWriteSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewSshKeySshKeysPost(
      xToken: string,
      sSHKeyWriteSchema: SSHKeyWriteSchema,
      options?: any
    ): AxiosPromise<object> {
      return SSHKeysApiFp(configuration).createNewSshKeySshKeysPost(
        xToken,
        sSHKeyWriteSchema,
        options
      )(axios, basePath);
    },
    /**
     * Deletes SSH key.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token. And the entered one will be ignored.   This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Delete Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSshKeySshKeysIdDelete(
      id: number,
      xToken: string,
      customerId?: string,
      options?: any
    ): AxiosPromise<object> {
      return SSHKeysApiFp(configuration).deleteSshKeySshKeysIdDelete(
        id,
        xToken,
        customerId,
        options
      )(axios, basePath);
    },
    /**
     * Retrieve a specific ssh key owned specified or current user.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary Get Ssh Key
     * @param {number} id
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSshKeySshKeysIdGet(
      id: number,
      xToken: string,
      customerId?: string,
      options?: any
    ): AxiosPromise<SSHKeyReadSchema> {
      return SSHKeysApiFp(configuration).getSshKeySshKeysIdGet(
        id,
        xToken,
        customerId,
        options
      )(axios, basePath);
    },
    /**
     * List of ssh keys for a user.     - Admins group should provide customer id to get SSH keys for that customer.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Ssh Keys
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSshKeysSshKeysGet(
      xToken: string,
      customerId?: string,
      options?: any
    ): AxiosPromise<Array<SSHKeyReadSchema>> {
      return SSHKeysApiFp(configuration).listSshKeysSshKeysGet(
        xToken,
        customerId,
        options
      )(axios, basePath);
    },
  };
};

/**
 * SSHKeysApi - interface
 * @export
 * @interface SSHKeysApi
 */
export interface SSHKeysApiInterface {
  /**
   * Creates a new SSH key for current or specified user.     - Admin group should provide desired customer_id to create SSH key for the specified user.    - For customer group, user id will be picked from the entered JWT token. And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Create New Ssh Key
   * @param {string} xToken
   * @param {SSHKeyWriteSchema} sSHKeyWriteSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApiInterface
   */
  createNewSshKeySshKeysPost(
    xToken: string,
    sSHKeyWriteSchema: SSHKeyWriteSchema,
    options?: any
  ): AxiosPromise<object>;

  /**
   * Deletes SSH key.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token. And the entered one will be ignored.   This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Delete Ssh Key
   * @param {number} id
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApiInterface
   */
  deleteSshKeySshKeysIdDelete(
    id: number,
    xToken: string,
    customerId?: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   * Retrieve a specific ssh key owned specified or current user.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Ssh Key
   * @param {number} id
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApiInterface
   */
  getSshKeySshKeysIdGet(
    id: number,
    xToken: string,
    customerId?: string,
    options?: any
  ): AxiosPromise<SSHKeyReadSchema>;

  /**
   * List of ssh keys for a user.     - Admins group should provide customer id to get SSH keys for that customer.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Ssh Keys
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApiInterface
   */
  listSshKeysSshKeysGet(
    xToken: string,
    customerId?: string,
    options?: any
  ): AxiosPromise<Array<SSHKeyReadSchema>>;
}

/**
 * SSHKeysApi - object-oriented interface
 * @export
 * @class SSHKeysApi
 * @extends {BaseAPI}
 */
export class SSHKeysApi extends BaseAPI implements SSHKeysApiInterface {
  /**
   * Creates a new SSH key for current or specified user.     - Admin group should provide desired customer_id to create SSH key for the specified user.    - For customer group, user id will be picked from the entered JWT token. And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Create New Ssh Key
   * @param {string} xToken
   * @param {SSHKeyWriteSchema} sSHKeyWriteSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApi
   */
  public createNewSshKeySshKeysPost(
    xToken: string,
    sSHKeyWriteSchema: SSHKeyWriteSchema,
    options?: any
  ) {
    return SSHKeysApiFp(this.configuration).createNewSshKeySshKeysPost(
      xToken,
      sSHKeyWriteSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Deletes SSH key.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token. And the entered one will be ignored.   This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Delete Ssh Key
   * @param {number} id
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApi
   */
  public deleteSshKeySshKeysIdDelete(
    id: number,
    xToken: string,
    customerId?: string,
    options?: any
  ) {
    return SSHKeysApiFp(this.configuration).deleteSshKeySshKeysIdDelete(
      id,
      xToken,
      customerId,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Retrieve a specific ssh key owned specified or current user.     - Admins group should provide customer id along with SSH key id.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary Get Ssh Key
   * @param {number} id
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApi
   */
  public getSshKeySshKeysIdGet(
    id: number,
    xToken: string,
    customerId?: string,
    options?: any
  ) {
    return SSHKeysApiFp(this.configuration).getSshKeySshKeysIdGet(
      id,
      xToken,
      customerId,
      options
    )(this.axios, this.basePath);
  }

  /**
   * List of ssh keys for a user.     - Admins group should provide customer id to get SSH keys for that customer.    - Customer group do not need to provide the customer id, As by default their id will be    fetched from entered JWT token.  And the entered one will be ignored.       This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Ssh Keys
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSHKeysApi
   */
  public listSshKeysSshKeysGet(
    xToken: string,
    customerId?: string,
    options?: any
  ) {
    return SSHKeysApiFp(this.configuration).listSshKeysSshKeysGet(
      xToken,
      customerId,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * SupportApi - axios parameter creator
 * @export
 */
export const SupportApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Close Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTicketTicketingTicketsTicketIdCloseGet(
      ticketId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ticketId' is not null or undefined
      if (ticketId === null || ticketId === undefined) {
        throw new RequiredError(
          "ticketId",
          "Required parameter ticketId was null or undefined when calling closeTicketTicketingTicketsTicketIdCloseGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling closeTicketTicketingTicketsTicketIdCloseGet."
        );
      }
      const localVarPath = `/ticketing/tickets/{ticket_id}/close`.replace(
        `{${"ticket_id"}}`,
        encodeURIComponent(String(ticketId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    ## Creates a followup for the ticket with the provided id in the body\'s ``items_id``.    ``Content`` can be HTML.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Followup
     * @param {string} xToken
     * @param {FollowUpCreateSchema} followUpCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFollowupTicketingFollowupsPost(
      xToken: string,
      followUpCreateSchema: FollowUpCreateSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling createFollowupTicketingFollowupsPost."
        );
      }
      // verify required parameter 'followUpCreateSchema' is not null or undefined
      if (followUpCreateSchema === null || followUpCreateSchema === undefined) {
        throw new RequiredError(
          "followUpCreateSchema",
          "Required parameter followUpCreateSchema was null or undefined when calling createFollowupTicketingFollowupsPost."
        );
      }
      const localVarPath = `/ticketing/followups`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof followUpCreateSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            followUpCreateSchema !== undefined ? followUpCreateSchema : {}
          )
        : followUpCreateSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Ticket
     * @param {string} xToken
     * @param {TicketCreateSchema} ticketCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTicketTicketingTicketsPost(
      xToken: string,
      ticketCreateSchema: TicketCreateSchema,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling createTicketTicketingTicketsPost."
        );
      }
      // verify required parameter 'ticketCreateSchema' is not null or undefined
      if (ticketCreateSchema === null || ticketCreateSchema === undefined) {
        throw new RequiredError(
          "ticketCreateSchema",
          "Required parameter ticketCreateSchema was null or undefined when calling createTicketTicketingTicketsPost."
        );
      }
      const localVarPath = `/ticketing/tickets`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      const needsSerialization =
        typeof ticketCreateSchema !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            ticketCreateSchema !== undefined ? ticketCreateSchema : {}
          )
        : ticketCreateSchema || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTicketingTicketsTicketIdGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ticketId' is not null or undefined
      if (ticketId === null || ticketId === undefined) {
        throw new RequiredError(
          "ticketId",
          "Required parameter ticketId was null or undefined when calling getTicketTicketingTicketsTicketIdGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getTicketTicketingTicketsTicketIdGet."
        );
      }
      const localVarPath = `/ticketing/tickets/{ticket_id}`.replace(
        `{${"ticket_id"}}`,
        encodeURIComponent(String(ticketId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (withDocuments !== undefined) {
        localVarQueryParameter["with_documents"] = withDocuments;
      }

      if (expandNames !== undefined) {
        localVarQueryParameter["expand_names"] = expandNames;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket Time Line
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {SortTypeEnum} [timelineSortType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      timelineSortType?: SortTypeEnum,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ticketId' is not null or undefined
      if (ticketId === null || ticketId === undefined) {
        throw new RequiredError(
          "ticketId",
          "Required parameter ticketId was null or undefined when calling getTicketTimeLineTicketingTicketsTicketIdTimelineGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling getTicketTimeLineTicketingTicketsTicketIdTimelineGet."
        );
      }
      const localVarPath = `/ticketing/tickets/{ticket_id}/timeline`.replace(
        `{${"ticket_id"}}`,
        encodeURIComponent(String(ticketId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (withDocuments !== undefined) {
        localVarQueryParameter["with_documents"] = withDocuments;
      }

      if (expandNames !== undefined) {
        localVarQueryParameter["expand_names"] = expandNames;
      }

      if (timelineSortType !== undefined) {
        localVarQueryParameter["timeline_sort_type"] = timelineSortType;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary List Categories
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCategoriesTicketingCategoryGet(
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listCategoriesTicketingCategoryGet."
        );
      }
      const localVarPath = `/ticketing/category`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    ``range``: (default: 0-50): a string with a couple of number for     start and end of pagination separated by a \'-\'. Ex: 150-200. Optional.     <br>     <br>     <h4>Check response headers for: </h4><br>     - ``Content-Range`` offset – limit / count<br><br>     - ``Accept-Range`` itemtype max        This endpoint can be used by following group(s):  ``customer``.
     * @summary List Tickets
     * @param {string} xToken
     * @param {string} [itemRange]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTicketsTicketingTicketsGet(
      xToken: string,
      itemRange?: string,
      expandNames?: boolean,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listTicketsTicketingTicketsGet."
        );
      }
      const localVarPath = `/ticketing/tickets`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (itemRange !== undefined) {
        localVarQueryParameter["item_range"] = itemRange;
      }

      if (expandNames !== undefined) {
        localVarQueryParameter["expand_names"] = expandNames;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Reopen Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reopenTicketTicketingTicketsTicketIdReopenGet(
      ticketId: number,
      xToken: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ticketId' is not null or undefined
      if (ticketId === null || ticketId === undefined) {
        throw new RequiredError(
          "ticketId",
          "Required parameter ticketId was null or undefined when calling reopenTicketTicketingTicketsTicketIdReopenGet."
        );
      }
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling reopenTicketTicketingTicketsTicketIdReopenGet."
        );
      }
      const localVarPath = `/ticketing/tickets/{ticket_id}/reopen`.replace(
        `{${"ticket_id"}}`,
        encodeURIComponent(String(ticketId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *    Search for tickets by name & category_id.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Search Tickets
     * @param {string} xToken
     * @param {string} [phrase] Retrieves ticket which their name or description contains this phrase.
     * @param {number} [categoryId] Filter tickets based on category id
     * @param {string} [searchRange] A range for search
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTicketsTicketingTicketsSearchGet(
      xToken: string,
      phrase?: string,
      categoryId?: number,
      searchRange?: string,
      expandNames?: boolean,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling searchTicketsTicketingTicketsSearchGet."
        );
      }
      const localVarPath = `/ticketing/tickets/search`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (phrase !== undefined) {
        localVarQueryParameter["phrase"] = phrase;
      }

      if (categoryId !== undefined) {
        localVarQueryParameter["category_id"] = categoryId;
      }

      if (searchRange !== undefined) {
        localVarQueryParameter["search_range"] = searchRange;
      }

      if (expandNames !== undefined) {
        localVarQueryParameter["expand_names"] = expandNames;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Upload File
     * @param {string} xToken
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileTicketingAttachmentsUploadPost(
      xToken: string,
      file: any,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling uploadFileTicketingAttachmentsUploadPost."
        );
      }
      // verify required parameter 'file' is not null or undefined
      if (file === null || file === undefined) {
        throw new RequiredError(
          "file",
          "Required parameter file was null or undefined when calling uploadFileTicketingAttachmentsUploadPost."
        );
      }
      const localVarPath = `/ticketing/attachments/upload`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SupportApi - functional programming interface
 * @export
 */
export const SupportApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Close Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTicketTicketingTicketsTicketIdCloseGet(
      ticketId: number,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).closeTicketTicketingTicketsTicketIdCloseGet(ticketId, xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    ## Creates a followup for the ticket with the provided id in the body\'s ``items_id``.    ``Content`` can be HTML.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Followup
     * @param {string} xToken
     * @param {FollowUpCreateSchema} followUpCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFollowupTicketingFollowupsPost(
      xToken: string,
      followUpCreateSchema: FollowUpCreateSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<AddItemReturnSchema> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).createFollowupTicketingFollowupsPost(
        xToken,
        followUpCreateSchema,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Ticket
     * @param {string} xToken
     * @param {TicketCreateSchema} ticketCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTicketTicketingTicketsPost(
      xToken: string,
      ticketCreateSchema: TicketCreateSchema,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<AddItemReturnSchema> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).createTicketTicketingTicketsPost(xToken, ticketCreateSchema, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTicketingTicketsTicketIdGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).getTicketTicketingTicketsTicketIdGet(
        ticketId,
        xToken,
        withDocuments,
        expandNames,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket Time Line
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {SortTypeEnum} [timelineSortType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      timelineSortType?: SortTypeEnum,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
        ticketId,
        xToken,
        withDocuments,
        expandNames,
        timelineSortType,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary List Categories
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCategoriesTicketingCategoryGet(
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).listCategoriesTicketingCategoryGet(xToken, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    ``range``: (default: 0-50): a string with a couple of number for     start and end of pagination separated by a \'-\'. Ex: 150-200. Optional.     <br>     <br>     <h4>Check response headers for: </h4><br>     - ``Content-Range`` offset – limit / count<br><br>     - ``Accept-Range`` itemtype max        This endpoint can be used by following group(s):  ``customer``.
     * @summary List Tickets
     * @param {string} xToken
     * @param {string} [itemRange]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTicketsTicketingTicketsGet(
      xToken: string,
      itemRange?: string,
      expandNames?: boolean,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).listTicketsTicketingTicketsGet(xToken, itemRange, expandNames, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Reopen Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reopenTicketTicketingTicketsTicketIdReopenGet(
      ticketId: number,
      xToken: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).reopenTicketTicketingTicketsTicketIdReopenGet(
        ticketId,
        xToken,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *    Search for tickets by name & category_id.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Search Tickets
     * @param {string} xToken
     * @param {string} [phrase] Retrieves ticket which their name or description contains this phrase.
     * @param {number} [categoryId] Filter tickets based on category id
     * @param {string} [searchRange] A range for search
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTicketsTicketingTicketsSearchGet(
      xToken: string,
      phrase?: string,
      categoryId?: number,
      searchRange?: string,
      expandNames?: boolean,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).searchTicketsTicketingTicketsSearchGet(
        xToken,
        phrase,
        categoryId,
        searchRange,
        expandNames,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Upload File
     * @param {string} xToken
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileTicketingAttachmentsUploadPost(
      xToken: string,
      file: any,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = SupportApiAxiosParamCreator(
        configuration
      ).uploadFileTicketingAttachmentsUploadPost(xToken, file, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SupportApi - factory interface
 * @export
 */
export const SupportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Close Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTicketTicketingTicketsTicketIdCloseGet(
      ticketId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(
        configuration
      ).closeTicketTicketingTicketsTicketIdCloseGet(
        ticketId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    ## Creates a followup for the ticket with the provided id in the body\'s ``items_id``.    ``Content`` can be HTML.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Followup
     * @param {string} xToken
     * @param {FollowUpCreateSchema} followUpCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFollowupTicketingFollowupsPost(
      xToken: string,
      followUpCreateSchema: FollowUpCreateSchema,
      options?: any
    ): AxiosPromise<AddItemReturnSchema> {
      return SupportApiFp(configuration).createFollowupTicketingFollowupsPost(
        xToken,
        followUpCreateSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Create Ticket
     * @param {string} xToken
     * @param {TicketCreateSchema} ticketCreateSchema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTicketTicketingTicketsPost(
      xToken: string,
      ticketCreateSchema: TicketCreateSchema,
      options?: any
    ): AxiosPromise<AddItemReturnSchema> {
      return SupportApiFp(configuration).createTicketTicketingTicketsPost(
        xToken,
        ticketCreateSchema,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTicketingTicketsTicketIdGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(configuration).getTicketTicketingTicketsTicketIdGet(
        ticketId,
        xToken,
        withDocuments,
        expandNames,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Get Ticket Time Line
     * @param {number} ticketId
     * @param {string} xToken
     * @param {boolean} [withDocuments]
     * @param {boolean} [expandNames]
     * @param {SortTypeEnum} [timelineSortType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
      ticketId: number,
      xToken: string,
      withDocuments?: boolean,
      expandNames?: boolean,
      timelineSortType?: SortTypeEnum,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(
        configuration
      ).getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
        ticketId,
        xToken,
        withDocuments,
        expandNames,
        timelineSortType,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary List Categories
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCategoriesTicketingCategoryGet(
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(configuration).listCategoriesTicketingCategoryGet(
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    ``range``: (default: 0-50): a string with a couple of number for     start and end of pagination separated by a \'-\'. Ex: 150-200. Optional.     <br>     <br>     <h4>Check response headers for: </h4><br>     - ``Content-Range`` offset – limit / count<br><br>     - ``Accept-Range`` itemtype max        This endpoint can be used by following group(s):  ``customer``.
     * @summary List Tickets
     * @param {string} xToken
     * @param {string} [itemRange]
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTicketsTicketingTicketsGet(
      xToken: string,
      itemRange?: string,
      expandNames?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(configuration).listTicketsTicketingTicketsGet(
        xToken,
        itemRange,
        expandNames,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Reopen Ticket
     * @param {number} ticketId
     * @param {string} xToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reopenTicketTicketingTicketsTicketIdReopenGet(
      ticketId: number,
      xToken: string,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(
        configuration
      ).reopenTicketTicketingTicketsTicketIdReopenGet(
        ticketId,
        xToken,
        options
      )(axios, basePath);
    },
    /**
     *    Search for tickets by name & category_id.       This endpoint can be used by following group(s):  ``customer``.
     * @summary Search Tickets
     * @param {string} xToken
     * @param {string} [phrase] Retrieves ticket which their name or description contains this phrase.
     * @param {number} [categoryId] Filter tickets based on category id
     * @param {string} [searchRange] A range for search
     * @param {boolean} [expandNames]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTicketsTicketingTicketsSearchGet(
      xToken: string,
      phrase?: string,
      categoryId?: number,
      searchRange?: string,
      expandNames?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(configuration).searchTicketsTicketingTicketsSearchGet(
        xToken,
        phrase,
        categoryId,
        searchRange,
        expandNames,
        options
      )(axios, basePath);
    },
    /**
     * This endpoint can be used by following group(s):  ``customer``.
     * @summary Upload File
     * @param {string} xToken
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileTicketingAttachmentsUploadPost(
      xToken: string,
      file: any,
      options?: any
    ): AxiosPromise<object> {
      return SupportApiFp(
        configuration
      ).uploadFileTicketingAttachmentsUploadPost(
        xToken,
        file,
        options
      )(axios, basePath);
    },
  };
};

/**
 * SupportApi - interface
 * @export
 * @interface SupportApi
 */
export interface SupportApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Close Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  closeTicketTicketingTicketsTicketIdCloseGet(
    ticketId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    ## Creates a followup for the ticket with the provided id in the body\'s ``items_id``.    ``Content`` can be HTML.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Create Followup
   * @param {string} xToken
   * @param {FollowUpCreateSchema} followUpCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  createFollowupTicketingFollowupsPost(
    xToken: string,
    followUpCreateSchema: FollowUpCreateSchema,
    options?: any
  ): AxiosPromise<AddItemReturnSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Create Ticket
   * @param {string} xToken
   * @param {TicketCreateSchema} ticketCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  createTicketTicketingTicketsPost(
    xToken: string,
    ticketCreateSchema: TicketCreateSchema,
    options?: any
  ): AxiosPromise<AddItemReturnSchema>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Get Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {boolean} [withDocuments]
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  getTicketTicketingTicketsTicketIdGet(
    ticketId: number,
    xToken: string,
    withDocuments?: boolean,
    expandNames?: boolean,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Get Ticket Time Line
   * @param {number} ticketId
   * @param {string} xToken
   * @param {boolean} [withDocuments]
   * @param {boolean} [expandNames]
   * @param {SortTypeEnum} [timelineSortType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
    ticketId: number,
    xToken: string,
    withDocuments?: boolean,
    expandNames?: boolean,
    timelineSortType?: SortTypeEnum,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary List Categories
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  listCategoriesTicketingCategoryGet(
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    ``range``: (default: 0-50): a string with a couple of number for     start and end of pagination separated by a \'-\'. Ex: 150-200. Optional.     <br>     <br>     <h4>Check response headers for: </h4><br>     - ``Content-Range`` offset – limit / count<br><br>     - ``Accept-Range`` itemtype max        This endpoint can be used by following group(s):  ``customer``.
   * @summary List Tickets
   * @param {string} xToken
   * @param {string} [itemRange]
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  listTicketsTicketingTicketsGet(
    xToken: string,
    itemRange?: string,
    expandNames?: boolean,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Reopen Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  reopenTicketTicketingTicketsTicketIdReopenGet(
    ticketId: number,
    xToken: string,
    options?: any
  ): AxiosPromise<object>;

  /**
   *    Search for tickets by name & category_id.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Search Tickets
   * @param {string} xToken
   * @param {string} [phrase] Retrieves ticket which their name or description contains this phrase.
   * @param {number} [categoryId] Filter tickets based on category id
   * @param {string} [searchRange] A range for search
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  searchTicketsTicketingTicketsSearchGet(
    xToken: string,
    phrase?: string,
    categoryId?: number,
    searchRange?: string,
    expandNames?: boolean,
    options?: any
  ): AxiosPromise<object>;

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Upload File
   * @param {string} xToken
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApiInterface
   */
  uploadFileTicketingAttachmentsUploadPost(
    xToken: string,
    file: any,
    options?: any
  ): AxiosPromise<object>;
}

/**
 * SupportApi - object-oriented interface
 * @export
 * @class SupportApi
 * @extends {BaseAPI}
 */
export class SupportApi extends BaseAPI implements SupportApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Close Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public closeTicketTicketingTicketsTicketIdCloseGet(
    ticketId: number,
    xToken: string,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).closeTicketTicketingTicketsTicketIdCloseGet(
      ticketId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    ## Creates a followup for the ticket with the provided id in the body\'s ``items_id``.    ``Content`` can be HTML.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Create Followup
   * @param {string} xToken
   * @param {FollowUpCreateSchema} followUpCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public createFollowupTicketingFollowupsPost(
    xToken: string,
    followUpCreateSchema: FollowUpCreateSchema,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).createFollowupTicketingFollowupsPost(
      xToken,
      followUpCreateSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Create Ticket
   * @param {string} xToken
   * @param {TicketCreateSchema} ticketCreateSchema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public createTicketTicketingTicketsPost(
    xToken: string,
    ticketCreateSchema: TicketCreateSchema,
    options?: any
  ) {
    return SupportApiFp(this.configuration).createTicketTicketingTicketsPost(
      xToken,
      ticketCreateSchema,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Get Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {boolean} [withDocuments]
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public getTicketTicketingTicketsTicketIdGet(
    ticketId: number,
    xToken: string,
    withDocuments?: boolean,
    expandNames?: boolean,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).getTicketTicketingTicketsTicketIdGet(
      ticketId,
      xToken,
      withDocuments,
      expandNames,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Get Ticket Time Line
   * @param {number} ticketId
   * @param {string} xToken
   * @param {boolean} [withDocuments]
   * @param {boolean} [expandNames]
   * @param {SortTypeEnum} [timelineSortType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
    ticketId: number,
    xToken: string,
    withDocuments?: boolean,
    expandNames?: boolean,
    timelineSortType?: SortTypeEnum,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).getTicketTimeLineTicketingTicketsTicketIdTimelineGet(
      ticketId,
      xToken,
      withDocuments,
      expandNames,
      timelineSortType,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary List Categories
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public listCategoriesTicketingCategoryGet(xToken: string, options?: any) {
    return SupportApiFp(this.configuration).listCategoriesTicketingCategoryGet(
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    ``range``: (default: 0-50): a string with a couple of number for     start and end of pagination separated by a \'-\'. Ex: 150-200. Optional.     <br>     <br>     <h4>Check response headers for: </h4><br>     - ``Content-Range`` offset – limit / count<br><br>     - ``Accept-Range`` itemtype max        This endpoint can be used by following group(s):  ``customer``.
   * @summary List Tickets
   * @param {string} xToken
   * @param {string} [itemRange]
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public listTicketsTicketingTicketsGet(
    xToken: string,
    itemRange?: string,
    expandNames?: boolean,
    options?: any
  ) {
    return SupportApiFp(this.configuration).listTicketsTicketingTicketsGet(
      xToken,
      itemRange,
      expandNames,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Reopen Ticket
   * @param {number} ticketId
   * @param {string} xToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public reopenTicketTicketingTicketsTicketIdReopenGet(
    ticketId: number,
    xToken: string,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).reopenTicketTicketingTicketsTicketIdReopenGet(
      ticketId,
      xToken,
      options
    )(this.axios, this.basePath);
  }

  /**
   *    Search for tickets by name & category_id.       This endpoint can be used by following group(s):  ``customer``.
   * @summary Search Tickets
   * @param {string} xToken
   * @param {string} [phrase] Retrieves ticket which their name or description contains this phrase.
   * @param {number} [categoryId] Filter tickets based on category id
   * @param {string} [searchRange] A range for search
   * @param {boolean} [expandNames]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public searchTicketsTicketingTicketsSearchGet(
    xToken: string,
    phrase?: string,
    categoryId?: number,
    searchRange?: string,
    expandNames?: boolean,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).searchTicketsTicketingTicketsSearchGet(
      xToken,
      phrase,
      categoryId,
      searchRange,
      expandNames,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This endpoint can be used by following group(s):  ``customer``.
   * @summary Upload File
   * @param {string} xToken
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public uploadFileTicketingAttachmentsUploadPost(
    xToken: string,
    file: any,
    options?: any
  ) {
    return SupportApiFp(
      this.configuration
    ).uploadFileTicketingAttachmentsUploadPost(
      xToken,
      file,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Transactions
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsTransactionsGet(
      xToken: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'xToken' is not null or undefined
      if (xToken === null || xToken === undefined) {
        throw new RequiredError(
          "xToken",
          "Required parameter xToken was null or undefined when calling listTransactionsTransactionsGet."
        );
      }
      const localVarPath = `/transactions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (customerId !== undefined) {
        localVarQueryParameter["customerId"] = customerId;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = end;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (xToken !== undefined && xToken !== null) {
        localVarHeaderParameter["X-Token"] = String(xToken);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Transactions
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsTransactionsGet(
      xToken: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TransactionListResponseSchema> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).listTransactionsTransactionsGet(
        xToken,
        customerId,
        start,
        end,
        page,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This endpoint can be used by following group(s):  ``customer``,``admin``.
     * @summary List Transactions
     * @param {string} xToken
     * @param {string} [customerId]
     * @param {number} [start]
     * @param {number} [end]
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsTransactionsGet(
      xToken: string,
      customerId?: string,
      start?: number,
      end?: number,
      page?: number,
      options?: any
    ): AxiosPromise<TransactionListResponseSchema> {
      return TransactionsApiFp(configuration).listTransactionsTransactionsGet(
        xToken,
        customerId,
        start,
        end,
        page,
        options
      )(axios, basePath);
    },
  };
};

/**
 * TransactionsApi - interface
 * @export
 * @interface TransactionsApi
 */
export interface TransactionsApiInterface {
  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Transactions
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {number} [start]
   * @param {number} [end]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApiInterface
   */
  listTransactionsTransactionsGet(
    xToken: string,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ): AxiosPromise<TransactionListResponseSchema>;
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi
  extends BaseAPI
  implements TransactionsApiInterface
{
  /**
   * This endpoint can be used by following group(s):  ``customer``,``admin``.
   * @summary List Transactions
   * @param {string} xToken
   * @param {string} [customerId]
   * @param {number} [start]
   * @param {number} [end]
   * @param {number} [page]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public listTransactionsTransactionsGet(
    xToken: string,
    customerId?: string,
    start?: number,
    end?: number,
    page?: number,
    options?: any
  ) {
    return TransactionsApiFp(
      this.configuration
    ).listTransactionsTransactionsGet(
      xToken,
      customerId,
      start,
      end,
      page,
      options
    )(this.axios, this.basePath);
  }
}
